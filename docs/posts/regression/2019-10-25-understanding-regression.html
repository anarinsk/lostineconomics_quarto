<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="JS HUHH">
<meta name="dcterms.date" content="2019-10-25">
<meta name="description" content="회귀 분석, 기하학적으로 한 방에 깨우치기">

<title>lostineconomics.com - Understanding Regression</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">lostineconomics.com</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../project.html" rel="" target="">
 <span class="menu-text">project</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/anarinsk" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/anarinsk" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Understanding Regression</h1>
  <div class="quarto-categories">
    <div class="quarto-category">regression</div>
  </div>
  </div>

<div>
  <div class="description">
    회귀 분석, 기하학적으로 한 방에 깨우치기
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>JS HUHH </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 25, 2019</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-JNRF3S74Z4"></script><section id="tl-dr" class="level2">
<h2 class="anchored" data-anchor-id="tl-dr">TL; DR</h2>
<section id="not-in-this-post" class="level3">
<h3 class="anchored" data-anchor-id="not-in-this-post">Not in This Post</h3>
<ul>
<li>회귀 분석에 관한 미주알 고주알</li>
</ul>
</section>
<section id="what-in-this-post" class="level3">
<h3 class="anchored" data-anchor-id="what-in-this-post">What in This Post</h3>
<ul>
<li>선형 대수를 통해 회귀 분석을 이해하면 새로운 깨달음을 얻을 수 있다.</li>
</ul>
</section>
</section>
<section id="regression-in-vector-space" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="regression-in-vector-space">Regression in vector space</h2>
<p>여기서 회귀 분석을 해설할 생각은 없다. 이미 너무나 많은 그리고 매우 훌륭한 내용들이 책, 웹, 강의로 넘쳐날테니까. 이 글의 용도는 그림 하나로 지나치기 쉬운 회귀 분석의 ’핵심’을 살피는 것이다. <a href="https://stats.stackexchange.com/questions/123651/geometric-interpretation-of-multiple-correlation-coefficient-r-and-coefficient">crossvalidated</a>에서 아래 그림을 보는 순간 일종의 ’돈오돈수’가 강림했다. (이렇게 이해하면 쉬웠을 것을…)</p>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 20.0%;justify-content: center;">
<p>&nbsp;</p>
</div>
<div class="quarto-figure quarto-figure-center" style="flex-basis: 60.0%;justify-content: center;">
<figure class="figure">
<p><a href="https://github.com/anarinsk/lie-regression/blob/master/assets/imgs/reg-in-vectorspace.png?raw=true" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="벡터 스페이스에 바라본 회귀 분석"><img src="https://github.com/anarinsk/lie-regression/blob/master/assets/imgs/reg-in-vectorspace.png?raw=true" class="img-fluid figure-img"></a></p>
<figcaption class="figure-caption">벡터 스페이스에 바라본 회귀 분석</figcaption>
</figure>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 20.0%;justify-content: center;">
<p>&nbsp;</p>
</div>
</div>
</div>
<p>먼저 우리에게 익숙한 회귀 분석 모델을 매트릭스로 적어보자.</p>
<p><span class="math display">\[
\underset{n \times 1}{\phantom{\mathbf \gamma}\mathbf{Y}\phantom{\mathbf \gamma}} = \underset{n \times k}{\phantom{\mathbf \gamma} \mathbf{X} \phantom{\mathbf \gamma} }\underset{k \times 1}{\boldsymbol \beta} + \underset{n \times 1}{\phantom{\boldsymbol \beta} \mathbf \varepsilon \phantom{\mathbf \gamma} }
\]</span></p>
<p>식에 관한 자세한 설명 역시 생략한다. 대충 <span class="math inline">\(n\)</span> 개의 관찰 수과 <span class="math inline">\(k\)</span> 개의 regressor를 지닌 중회귀 분석 모형이라고 생각하면 되겠다. 앞서 본 그림은 보통 회귀 분석의 예시로 많이 활용되는 아래 그림과는 다르다.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>흔히 <span class="math inline">\(\mathbf Y\)</span>를 종속변수, <span class="math inline">\(\mathbf X\)</span>를 독립변수로 부르기도 한다. 하지만 이러한 이름에는 혼란의 여지가 있다. 여기서는 regressor, regressand라는 영어 표현을 그대로 쓰도록 하겠다.</p>
</div></div><div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 20.0%;justify-content: center;">
<p>&nbsp;</p>
</div>
<div class="quarto-figure quarto-figure-center" style="flex-basis: 60.0%;justify-content: center;">
<figure class="figure">
<p><a href="https://github.com/anarinsk/lie-regression/blob/master/assets/imgs/simpe_reg.png?raw=true" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="독립변수 1개인 회귀 분석"><img src="https://github.com/anarinsk/lie-regression/blob/master/assets/imgs/simpe_reg.png?raw=true" class="img-fluid figure-img"></a></p>
<figcaption class="figure-caption">독립변수 1개인 회귀 분석</figcaption>
</figure>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 20.0%;justify-content: center;">
<p>&nbsp;</p>
</div>
</div>
</div>
<p>위 그림은 1개의 regressor가 존재할 때 이것과 regressand를 그대로 2차원 평면에 관찰 수만큼 찍은 것이다. 첫번째 그림에서 “Observed Y”는 점 하나가 <span class="math inline">\(n\)</span> 개의 regressand를 모두 포괄한다. <span class="math inline">\(\mathbf{Y} \in {\mathbb R}^{n}\)</span> 벡터, 즉 <span class="math inline">\(n\)</span> 차원 벡터이고, 이것이 회귀식 좌변의 관찰값 <span class="math inline">\(n\)</span> 개를 표현한다.</p>
<p>이제 선형대수의 세계로 들어가보자. <span class="math inline">\(\mathbf X\)</span>의 열(column)이 각각 <span class="math inline">\(n\)</span> 개의 관찰 값을 지닌 regressor에 해당한다. 이 각각의 컬럼 <span class="math inline">\(x_i\)</span>는 <span class="math inline">\(x_i \in {\mathbb R}^{n}\)</span> 벡터이다. <span class="math inline">\(x_i\)</span> 벡터 <span class="math inline">\(k\)</span> 개가 생성할 수 있는 공간이 <span class="math inline">\(\mathbf X\)</span>의 열 공간(column space)이다. 앞으로 이를 col <span class="math inline">\(\mathbf X\)</span>로 표기하자.</p>
<p>이렇게 생각하면 좋겠다. <span class="math inline">\(x_i \in {\mathbb R}^{n}\)</span> 벡터가 <span class="math inline">\(k(&lt;n)\)</span> 개 있다고 하자. 이는 <span class="math inline">\(n\)</span> 보다 차원이 낮기 때문에 기하학적으로는 <span class="math inline">\(n\)</span> 차원 공간에서 초평면(hyperplane)으로 나타날 것이다. 위 그림에서 컬럼 스페이스가 평면으로 표현되는 것은 이러한 취지다. 3차원 벡터의 열 공간이 생성하는 초평면을 예시하면 아래와 같다.</p>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 20.0%;justify-content: center;">
<p>&nbsp;</p>
</div>
<div class="quarto-figure quarto-figure-center" style="flex-basis: 60.0%;justify-content: center;">
<figure class="figure">
<p><a href="https://miro.medium.com/max/2240/1*VUmUxo3G2UTugIiZ26Pusw@2x.jpeg" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="2차원 컬럼 스페이스"><img src="https://miro.medium.com/max/2240/1*VUmUxo3G2UTugIiZ26Pusw@2x.jpeg" class="img-fluid figure-img"></a></p>
<figcaption class="figure-caption">2차원 컬럼 스페이스</figcaption>
</figure>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 20.0%;justify-content: center;">
<p>&nbsp;</p>
</div>
</div>
</div>
<p>col <span class="math inline">\(\mathbf X\)</span>의 최대 차원, 즉 <span class="math inline">\(\mathbf X\)</span>의 랭크(위수)는 무엇일까? 회귀 분석에서는 대체로 <span class="math inline">\(n &gt; k\)</span>가 일반적이고 이런 상황에서 <span class="math inline">\(\mathbf X\)</span>의 랭크는 <span class="math inline">\(k\)</span>를 넘을 수 없다. 다시 말하면, <span class="math inline">\(\mathbf X\)</span>가 생성하는(span)하는 컬럼 스페이스의 차원의 크기가 <span class="math inline">\(k\)</span>를 넘을 수 없다. 그리고 잘 된 회귀 분석이라면 <span class="math inline">\({\rm rank}(\mathbf X) = k\)</span>를 만족한다.</p>
<p>맨 앞에 제시했던 그림을 다시 보자. 아래 색칠된 평면이 <span class="math inline">\(\mathbf X\)</span>가 생성하는 컬럼 스페이스, 즉 col <span class="math inline">\(\mathbf X\)</span>를 표현하고 있다. 몹시 특별한 경우가 아니라면 <span class="math inline">\(\mathbf Y \in {\mathbb R}^{n}\)</span> 벡터가 col <span class="math inline">\(\mathbf X\)</span>에 속할 가능성은 없다. 그렇다면 회귀 분석의 필요도 애초에 없었을 것이다. col <span class="math inline">\(\mathbf X\)</span>를 통해서 <span class="math inline">\(\mathbf Y\)</span>를 완벽하게 예측할 수 있는데 무슨 걱정이 있겠는가? 대체로 우리가 마주하는 상황은 <span class="math inline">\(n\)</span> 차원 벡터를 <span class="math inline">\(k\)</span> 차원 공간에 끼워 넣기 힘든 상황이다.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>이를 선형 대수에서 배운 연립방정식을 푸는 문제로 이해해도 좋겠다. <span class="math inline">\(A x = b(b \neq \mathbf{0})\)</span>라고 하자. <span class="math inline">\(n\)</span> 개의 미지수가 유일한 해를 지니고 위해서는 <span class="math inline">\({\rm rank}(A) = n\)</span>이어야 한다. 즉 서로 독립인 식이 <span class="math inline">\(n\)</span> 개 주어져야 고유의 해 <span class="math inline">\(x\)</span>를 찾을 수 있다. 그런데 회귀 분석은 식이 <span class="math inline">\(k(&lt;n)\)</span> 개만 주어진 상황이다.</p>
</div></div><p>회귀 분석의 목표는 regressor를 통해서, 더 정확하게는 regressor의 열 공간이 생성하는 초 평면을 이용해서, regressand를 ‘가장’ 잘 설명하는 무엇을 찾는 것이다. 즉 회귀 분석이란 regressand와 ‘닮은’ 것을 col <span class="math inline">\(\mathbf X\)</span>에서 찾는 것이다. 직관적으로 쉽게 떠올릴 수 있는 것은 이 평면과 <span class="math inline">\(\mathbf Y\)</span>의 (유클리드) 거리를 가장 짧게 만들어주는 벡터일 것이다. 그리고 이 최단거리는 <span class="math inline">\(\mathbf Y\)</span>에서 <span class="math inline">\(\mathbf X\)</span> 컬럼 스페이스로 내린 수선의 발이 닿는 col <span class="math inline">\(\mathbf X\)</span>의 지점이다. col <span class="math inline">\(\mathbf X\)</span> 내에 있는 이런 지점을 찾는 연산자(operator)가 회귀 분석의 추정 계수 <span class="math inline">\(\hat{\boldsymbol \beta}\)</span>이다. 즉,</p>
<p><span class="math display">\[
\hat{\boldsymbol \beta} = ({\mathbf X}'{\mathbf X})^{-1} ({\mathbf X}' \mathbf Y)
\]</span></p>

<div class="no-row-height column-margin column-container"><div class="">
<p>정석은 아니지만 이 연산자를 이해하는 흥미로운 방법이 있다.</p>
<p><span class="math inline">\({\mathbf X} {\boldsymbol \beta} = {\mathbf Y}\)</span>가 연립방정식이라면 해는 <span class="math inline">\({\mathbf X}^{-1}\)</span>을 구해서 얻을 수 있을 것이다. 하지만 <span class="math inline">\({\mathbf X} \in \mathbb R^{n \times k}\)</span>이므로 딱 떨어지는 특수해 1개를 구할 수 없다. 되도록 근사값의 해를 구하려면 어떻게 해야 할까?</p>
<p><span class="math display">\[
\begin{aligned}
{\mathbf X}'{\mathbf X} \hat{\boldsymbol \beta} &amp; = {\mathbf X}'{\mathbf Y} \\
\hat{\boldsymbol \beta} &amp; = ({\mathbf X}'{\mathbf X})^{-1}{\mathbf X}'{\mathbf Y}
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\hat{\boldsymbol \beta}\)</span>가 왠지 원래 식의 근사값으로 기능할 것 같지 않은가? (실제로 그렇다)</p>
</div></div><p>이 연산자를 reggressor의 모음인 col <span class="math inline">\(\mathbf X\)</span>에 적용하면, <span class="math inline">\(\mathbf{X} \hat{\boldsymbol \beta} =\hat{\mathbf Y}\)</span>이 산출된다. 그림에서 보듯이 <span class="math inline">\(\hat{\mathbf Y}\)</span>은 <span class="math inline">\(\mathbf Y\)</span>와 col <span class="math inline">\(\mathbf X\)</span>의 거리를 최소화하는 위치에 존재한다. <span class="math inline">\(\hat{\mathbf Y}\)</span>는 어떤 벡터일까? <span class="math inline">\(\hat{\mathbf Y} \in {\mathbb R}^n\)</span> 벡터지만, col <span class="math inline">\(\mathbf X(\in {\mathbb R}^k)\)</span>내에 위치하고 있다. <span class="math inline">\(n\)</span> 차원이 <span class="math inline">\(k\)</span> 차원으로 축소된 셈이다. 이것이 회귀 분석의 기하적 핵심이다.</p>
<p>선형 대수의 관점에서 내용을 다시 음미해보자. <span class="math inline">\(x_i \in {\mathbb R}^n\)</span> (for <span class="math inline">\(i = 1, \dotsc, k\)</span>) 벡터의 리그레서 <span class="math inline">\(k\)</span> 개를 선형 결합해서 초평면의 한점, 즉 원래의 관찰 <span class="math inline">\(\mathbf Y\)</span>와 최소 거리를 지니는 벡터를 찾아야 한다. 이 거리를 최소화하는 <span class="math inline">\(\beta_i\)</span>를 알고 있다면 이 벡터는 다음과 같이 표현된다. <span class="math inline">\({\mathbf X} = [x_1, \dotsc, x_k]\)</span>일 때,</p>
<p><span class="math display">\[
\begin{aligned}
\underset{(n \times 1)}{\hat{\mathbf Y}} &amp; = {\mathbf X} {\boldsymbol \beta} \\
&amp; = [x_1, \dotsc, x_k]
\begin{bmatrix}
\beta_1 \\
\vdots \\
\beta_k
\end{bmatrix} \\
&amp;=
x_1 \beta_1 + \dotsc + x_k \beta_k
\end{aligned}
\]</span></p>
<p>위의 벡터 스페이스 그림을 다시 한 번 노려보시라. <span class="math inline">\(\beta_i\)</span>는 col <span class="math inline">\(\mathbf X\)</span>를 구성하는 벡터 <span class="math inline">\(x_i\)</span>에 부여되는 선형 결합의 가중치를 의미한다.</p>
</section>
<section id="rm-r2은-피타고라스-정리의-용용" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="rm-r2은-피타고라스-정리의-용용"><span class="math inline">\(\rm R^2\)</span>은 피타고라스 정리의 용용</h2>
<p>이제 <span class="math inline">\(\mathrm R^2\)</span>의 의미를 살펴보자. 결론부터 이야기하면 <span class="math inline">\(\mathrm R^2\)</span>는 그림에서 <span class="math inline">\((\mathbf Y - \overline{\mathbf Y})\)</span> 벡터와 <span class="math inline">\((\hat{\mathbf Y}-\overline{\mathbf Y})\)</span> 벡터가 이루는 각의 코사인 값, 즉 <span class="math inline">\(\cos \theta\)</span>다. 잠깐! 왜 직접 거리를 재지 않고 코사인 값을 재는 것일까? 우리는 얼마나 가까운지를 판단하기 쉽지 않다. 그래서 가까운 정도를 상대적인 비율로 나타내면 좋을 것이다. 즉, regressor의 컬럼 스페이스에 위치한 <span class="math inline">\(\overline{\mathbf Y}\)</span>를 기준으로 거리를 재는 셈이다. 이렇게 측정된 상대적인 거리가 <span class="math inline">\(\cos \theta\)</span>이다. 이는 원점을 중심으로 두 벡터 사이의 코사인 값을 재는 코사인 유사도와 거의 같은 개념이다! 코사인 유사도란 길이가 서로 다른 두 벡터가 얼마나 비슷한지를 측정한다. 이를 응용하면 <span class="math inline">\(\mathrm R^2\)</span>란 관찰된 값(<span class="math inline">\(\mathbf Y\)</span>)과 피팅된 값(<span class="math inline">\(\mathbf {\hat Y}\)</span>)이 얼마나 비슷한지를 측정한다.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>이런 면에서 보면, <span class="math inline">\(\mathrm R^2\)</span>에 코사인 유사도가 숨어 있는 셈이다. 두 벡터의 코사인 유사도란 개별 벡터가 지니고 있는 (유클리드) 길이와 관계 없이 벡터의 지향성을 중심으로 비슷한 정도를 파악하는 것이다. <span class="math inline">\(\mathrm R^2\)</span> 역시 마찬가지다.</p>
</div></div><p><span class="math inline">\(\overline{\mathbf Y}\)</span>는 무엇일까? 포스팅의 맨 처음 보았던 그림과 같이 <span class="math inline">\(\overline{Y} \mathbf{1}_n\)</span>로 표기할 수 있다. <span class="math inline">\(\mathbf Y\)</span>의 평균값 <span class="math inline">\(\overline{Y}\)</span>만으로 구성된 <span class="math inline">\((n \times 1)\)</span> 벡터다. 이 벡터는 col <span class="math inline">\(\mathbf X\)</span> 안에 있을까? 당연히 그렇다. <span class="math inline">\(\mathbf X\)</span>는 (이상적으로는) <span class="math inline">\(k(&lt;n)\)</span> 차원의 벡터이고, <span class="math inline">\(\overline{\mathbf Y}\)</span>는 1차원 벡터다. 따라서 col <span class="math inline">\(\mathbf X\)</span> 안 어딘가에 <span class="math inline">\(\overline{\mathbf Y}\)</span>이 있다.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>왜 그런지 잠시 따져보자. 앞서 보았듯이 regressor의 평면은 <span class="math inline">\(\alpha_1 x_1 + \dotsb + \alpha_k x_k\)</span> 와 같은 형태의 선형 결합을 통해 달성된다. 즉, <span class="math inline">\(\alpha_i\)</span>를 어떻게 잡는지에 따라서 <span class="math inline">\(k\)</span> 차원까지 이 식을 통해서 생성할 수 있다. 그런데 <span class="math inline">\(\overline{\mathbf Y}\)</span>는 1차원 즉, 모든 원소가 <span class="math inline">\(\overline{y}\)</span>, 즉 <span class="math inline">\(y\)</span>의 평균이다. 따라서 이를 만족하는 <span class="math inline">\(\alpha_i\)</span>(for <span class="math inline">\(i = 1, \dotsc, k\)</span>)를 <span class="math inline">\({\rm col}~{\mathbf X}\)</span>에서 반드시 찾을 수 있다.</p>
</div></div><p>그렇다면 이 코사인 값의 의미는 무엇일까? 첫번째 그림에서 보듯이 세 개의 벡터가 직각삼각형을 이루고 있으므로 아래의 식이 성립한다.</p>
<p><span class="math display">\[
\underset{\text{TSS}}{\Vert \mathbf Y - \overline{\mathbf Y} \Vert^2} = \underset{\text{RSS}}{\Vert \mathbf Y - \hat{\mathbf Y} \Vert^2} + \underset{\text{ESS}}{\Vert \hat{\mathbf Y} - \overline{\mathbf Y} \Vert^2}
\]</span></p>
<p>흔한 피타고라스의 정리다. 그런데 이것 어디서 많이 보던 식이다. 회귀 분석 배우면 언제나 나오는 식이다. Regressand의 평균과 관찰의 이른바 총 제곱의 합(TSS: Total Sum of Squares)은 설명된 제곱의 합(ESS: Explained Sum of Squares)과 잔차 제곱의 합(RSS:Residual Sum of Squares)와 같다. 대체로 복잡하게 소개되는 이 식이 기하학적으로 보면 그냥 피타고라스의 공식에 불과한 것이다.</p>
<p>양변을 <span class="math inline">\(\Vert \mathbf Y - \overline{\mathbf Y} \Vert^2\)</span>으로 나누면 다음과 같다.</p>
<p><span class="math display">\[
1 =  \dfrac{\Vert \mathbf Y - \hat{\mathbf Y} \Vert^2}{\Vert \mathbf Y - \overline{\mathbf Y} \Vert^2} + \dfrac{\Vert \hat{\mathbf Y} - \overline{\mathbf Y} \Vert^2}{\Vert \mathbf Y - \overline{\mathbf Y} \Vert^2}
\]</span></p>
<p>정의에 따라서 <span class="math inline">\(1 = \dfrac{\text{RSS}} {\text{TSS}} + {\mathrm R}^2\)</span>가 된다. 즉,</p>
<p><span class="math display">\[
  {\mathrm R}^2 = 1 - \dfrac{\text{RSS}}{\text{TSS}}
\]</span></p>
<p>사실 <span class="math inline">\(\textrm R^2\)</span>는 가끔 회귀 분석의 성과 지표로 남용되는 경우가 있다. 이렇게 기하학적으로 보면 col <span class="math inline">\(\mathbf X\)</span> 내에 표현된 <span class="math inline">\(\hat{\mathbf Y}\)</span> 가 <span class="math inline">\(\mathbf Y\)</span>와 얼마나 가깝게 있는지를 <span class="math inline">\(\overline{\mathbf Y}\)</span>를 기준으로 지표화한 것에 불과하다. <span class="math inline">\({\mathrm R}^2\)</span>는 회귀 분석의 성과 지표로 어떤 의미를 지닐까? 분석의 목표가 회귀 분석을 통한 예측이라면, 즉 원래 관찰값과 예측된 값이 얼마나 떨어져 있는지 여부가 중요하다면 <span class="math inline">\(\textrm R^2\)</span>는 의미를 지닐 수 있다. 반면, 분석의 목표가 회귀 분석을 통한 이러한 종류의 예측이 아니라 특정한 regressor의 인과관계에 관한 추정이라면, <span class="math inline">\(\textrm R^2\)</span>는 거의 무시해도 좋다.</p>
<p>아울러 회귀 분석이라는 이름을 달고 있지만 전형적인 회귀 분석의 방법을 따르지 않는 기법에서 <span class="math inline">\(\textrm R^2\)</span>가 정의되지 않는 경우도 있다. 잘 알려진 로지스틱 회귀가 이에 해당한다. 로지스틱 회귀에서 회귀 계수의 추정은 여기서 봤듯이 관찰과 col <span class="math inline">\(\mathbf X\)</span> 사이의 거리를 최소화하는 방식이 아니라 우도(likelihood)를 극대화하는 방식을 따른다. 따라서 벡터 공간의 최소 거리라는 개념에 기반한 <span class="math inline">\(\textrm R^2\)</span>를 로지스틱 회귀에서는 정의할 수 없다.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>궁여지책으로 이와 유사한 지표를 만들어낼 수는 있겠다. <a href="https://thestatsgeek.com/2014/02/08/r-squared-in-logistic-regression">여기</a>를 참고하라.</p>
</div></div></section>
<section id="곁눈질-regression-vs-pca" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="곁눈질-regression-vs-pca">곁눈질: Regression vs PCA</h2>
<p>회귀 분석과 PCA는 어떻게 다른가? 여러가지 답이 있을 수 있다. 그걸 다 소개하겠다는 게 아니다. 둘이 데이터 모델링의 시야에서 어떻게 다른지를 살펴보는 게 이 글의 목적이다. 이 글은 둘을 어떻게 실행하는지를 다루지 않는다. 앞선 PCA 관련 <a href="https://anarinsk.github.io/lie-math_pca/">포스팅</a>을 읽고 오시면 이해에 도움이 될 것이다.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>더 자세한 내용은 <a href="https://anarinsk.github.io/lie-qa_reg_pca/">여기</a>를 참고하자.</p>
</div></div><section id="공통점" class="level3">
<h3 class="anchored" data-anchor-id="공통점">공통점</h3>
<section id="feature" class="level4">
<h4 class="anchored" data-anchor-id="feature">Feature</h4>
<p>일단 둘 다 <span class="math inline">\(k\)</span> 개의 feature 비슷한 것을 지닌다. 그리고 <span class="math inline">\(n\)</span> 개의 데이터 포인트가 제시된다.</p>
</section>
<section id="차원-축소" class="level4">
<h4 class="anchored" data-anchor-id="차원-축소">차원 축소</h4>
<p>흔히 PCA를 차원축소의 방법으로 이해하는데, 이 말은 맞다. 반대로 회귀 분석은 이와 다르다고 이해하는 경우가 많은데 이 말은 틀리다. 회귀 분석도 어떻게 보면 ’차원 축소’다. 회귀 분석에서 target 변수는 <span class="math inline">\(n\)</span> 차원 공간 위의 주어진 한 점이다. 우리의 목표는 이 한 점을 잘 설명하는 더 낮은 차원의 어떤 지점을 찾는 것이다. 이런 점에서 본다면 회귀 분석 역시 차원 축소의 한 방법이라고 봐야 할 것이다.</p>
</section>
<section id="극소화" class="level4">
<h4 class="anchored" data-anchor-id="극소화">극소화</h4>
<p>PCA에서 ’분산 최대화’에 이르기까지 과정을 생략하다보면, PCA를 별도의 어떤 방법으로 인식하곤 한다. 그런데 앞선 포스팅에서 보았듯이 ’분산 최대화’란 사실 피처 벡터와 이를 예측하기 위한 어떤 벡터 사이의 거리를 최소화하는 과정에서 도출된 결과다. 이런 점에서 본다면, 회귀 분석이든 PCA는 MSE(Mean Square Error)를 최소화한다는 점에서는 목적 함수의 유형은 동일하다.</p>
</section>
</section>
<section id="차이점" class="level3">
<h3 class="anchored" data-anchor-id="차이점">차이점</h3>
<section id="supervised-or-unsupervised" class="level4">
<h4 class="anchored" data-anchor-id="supervised-or-unsupervised">Supervised or Unsupervised?</h4>
<p>회귀 분석과 PCA를 지도 학습(supervised learning), 비지도 학습(unsupervised learning)으로 구분할 수는 없다. 다만 이 구분과 어느 정도 비슷한 부분이 있다. 회귀 분석은 target이 있다. 이 타겟과의 거리를 최소화하는 feature 공간의 어떤 위치를 찾는 것이 목적이다. 반면, PCA에는 target이 없다. <span class="math inline">\(k\)</span> 개의 feature를 최소 거리로 투영할 수 있는 스크린 벡터를 찾는게 목적이다. 간단히 말해서 PCA는 target 없이 벡터의 거리가 1인 임의의 프로젝션 벡터를 찾는 것이 목적이다.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"openEffect":"zoom","selector":".lightbox","loop":true,"descPosition":"bottom","closeEffect":"zoom"});</script>



</body></html>