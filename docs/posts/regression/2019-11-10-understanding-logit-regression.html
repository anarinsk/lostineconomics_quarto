<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="JS HUHH">
<meta name="dcterms.date" content="2019-11-10">
<meta name="description" content="로지스틱 회귀를 이해해봅시다!">

<title>lostineconomics.com - Understanding Logit Regression</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">lostineconomics.com</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://www.lostinbooks.club"> 
<span class="menu-text">lostinbooks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../project.html"> 
<span class="menu-text">project</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/anarinsk"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/anarinsk"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-JNRF3S74Z4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-JNRF3S74Z4');
</script>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Understanding Logit Regression</h1>
  <div class="quarto-categories">
    <div class="quarto-category">regression</div>
  </div>
  </div>

<div>
  <div class="description">
    로지스틱 회귀를 이해해봅시다!
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>JS HUHH </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 10, 2019</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="tl-dr" class="level2">
<h2 class="anchored" data-anchor-id="tl-dr">TL; DR</h2>
<ul>
<li>로짓 회귀는 우리가 알던 그 ’회귀’와 다르다!</li>
<li>로짓 회귀는 아래와 같은 데이터 모형에 기반을 둔 추정법이다.</li>
</ul>
<p><span class="math display">\[
\ln \dfrac{p(\boldsymbol{x_i})}{1-p(\boldsymbol{x_i})} =\boldsymbol{x_i}\boldsymbol{\beta}
\]</span></p>
<ul>
<li>회귀식의 계수 <span class="math inline">\(\boldsymbol{\beta}\)</span>를 해석할 때 주의하자. 이를 통상적인 회귀 분석의 계수(한계 효과)처럼 해석하려면 별도의 계산이 필요하다.</li>
</ul>
</section>
<section id="로짓-회귀-제대로-알고-있나" class="level2">
<h2 class="anchored" data-anchor-id="로짓-회귀-제대로-알고-있나">로짓 회귀, 제대로 알고 있나?</h2>
<p>기계 학습을 배우게 되면, 로짓 회귀는 첫 챕터에서 그냥 쓱 지나치기 쉽다. 이어 등장하는 랜덤 포레스트, SVM, 뉴럴넷 등이 더 진보된 방법으로 보이기 때문이다. 로짓 회귀는 단순하면서도 강력한 방법이다. 나는 분류(classification)의 문제에 접근할 때 로짓 회귀를 먼저 해본다. 로짓 회귀에서 ’견적’이 나오면 그 질문 혹은 문제는 더 흥미로운 형태로 진화할 가능성이 높다. 반면 로짓 회귀에서 싹수가 없으면 더 복잡한 고급 방법도 소용이 없는 경우가 많다. 요컨대 로짓 회귀는 시간 낭비를 막는 일종의 ’맛보기’로서도 유용하다.</p>
</section>
<section id="로짓-함수는-어떻게-등장하나" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="로짓-함수는-어떻게-등장하나">로짓 함수는 어떻게 등장하나?</h2>
<p>로짓 회귀는 말 그대로 로지스틱 함수(logistic function)를 활용하는 회귀 분석이라는 뜻이다. 로지스틱 함수는 어디서 어떻게 등장할까? 로짓 회귀의 데이터 형태부터 살펴보자. 종속 변수, 반응(response), regressand 등 다양한 형태로 불리는 식의 좌변은 0 또는 1로만 되어 있다. 어떤 상태라면 1, 그렇지 않으면 0이다. 이때 0 또는 1은 값 자체로 의미를 지니지 않는다. 이는 범주형 변수로서 True or False와 같은 이항 변수로 이해하면 좋겠다. 식의 우변에는 통상적인 독립 변수, 예측 변수(predictor)가 등장한다.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>생각난 김에 짬을 내 회귀식에서 좌변과 우변을 지칭하는 용어를 정리해보자. 취향에 맞춰서 쓰되 일관성만 갖추면 되겠다.</p>
<table class="table">
<thead>
<tr class="header">
<th>좌변</th>
<th>우변</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(y\)</span></td>
<td><span class="math inline">\(x\)</span>, <span class="math inline">\(\boldsymbol X\)</span></td>
</tr>
<tr class="even">
<td>dependent variable</td>
<td>independent variables</td>
</tr>
<tr class="odd">
<td>response variable</td>
<td>predictor variable</td>
</tr>
<tr class="even">
<td>regressand</td>
<td>regressor</td>
</tr>
<tr class="odd">
<td>criterion</td>
<td>covariate</td>
</tr>
<tr class="even">
<td>predicted variable</td>
<td>controlled variable</td>
</tr>
<tr class="odd">
<td>measured variable</td>
<td>manipulated variable</td>
</tr>
<tr class="even">
<td>explained variable</td>
<td>explanatory variable</td>
</tr>
<tr class="odd">
<td>experimental variable</td>
<td>exposure variable</td>
</tr>
<tr class="even">
<td>responding variable</td>
<td>covariate</td>
</tr>
<tr class="odd">
<td>outcome variable</td>
<td>covariate</td>
</tr>
<tr class="even">
<td>output variable</td>
<td>input variable</td>
</tr>
<tr class="odd">
<td>endogenous variable</td>
<td>exogenous variable</td>
</tr>
<tr class="even">
<td>target</td>
<td>feature</td>
</tr>
<tr class="odd">
<td>label</td>
<td>feature</td>
</tr>
</tbody>
</table>
</div></div><section id="어떤-경우-ols는-곤란한가" class="level3">
<h3 class="anchored" data-anchor-id="어떤-경우-ols는-곤란한가">어떤 경우 OLS는 곤란한가?</h3>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[-1, 3.5, -1]">
<div class="quarto-layout-row">
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 18.2%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 63.6%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://miro.medium.com/max/1280/0*gKOV65tvGfY8SMem.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" data-glightbox="description: .lightbox-desc-1" title="로지스틱 리그레션이 필요한 순간"><img src="https://miro.medium.com/max/1280/0*gKOV65tvGfY8SMem.png" class="img-fluid figure-img" alt="로지스틱 리그레션이 필요한 순간"></a></p>
<figcaption>로지스틱 리그레션이 필요한 순간</figcaption>
</figure>
</div>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 18.2%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
</div>
</div>
<p>독립 변수가 하나인 모형을 가정하고 위의 그림을 보자. 종속 변수가 0, 1인 상태로 그대로 회귀 분석을 하면 그림의 왼쪽 같이 된다. 회귀식의 기울기를 구할 수 있으니 된 것 아니냐? 아니다. 앞서 0과 1은 값 그 자체로 의미를 지니지 않는다고 말했다. 그런데 이를 그대로 값으로 바꿔서 회귀 분석을 해도 좋은 것일까? 그러기에는 어딘가 찜찜하다.</p>
<p>게다가 <span class="math inline">\(x\)</span> 값에 따라서 회귀식의 예측치가 <span class="math inline">\([0,1]\)</span>을 벗어날 수 있다. 임의로 계단 함수를 다시 얹어서 OLS(통상적인 최소자승법이라는 의미에서 Ordinary Least Squares라고 흔히 부른다)를 구제할 수도 있겠다. 즉,</p>
<p><span class="math display">\[
s(\beta x) =
\begin{cases}
1 &amp; \text{if $\beta x \geq 1$}  \\
0 &amp; \text{if $\beta x &lt; 0$}
\end{cases}
\]</span></p>
<p>회귀식의 예측을 확률에 맞게 임의로 꺾어주는 것이다. 이러한 과정을 조금 더 ‘부드럽게’ 혹은 보다 ‘그럴 듯하게’ 할 수 없을까?</p>
</section>
<section id="범주형에서-확률로" class="level3">
<h3 class="anchored" data-anchor-id="범주형에서-확률로">범주형에서 확률로</h3>
<p>앞서 0, 1은 값 자체로는 아무 의미를 지니지 않는다고 말했다. 통상적인 회귀 분석의 종속 변수는 실수 형태다. 그렇다면 0, 1을 실수로 바꾸면 어떨까. 범주형 변수가 결국 상태를 나타내는 것이라면 1이라는 상태를 지닐 ’확률’을 추정하는 문제로 바꿔 생각해볼 수 있겠다. 즉,</p>
<p><span class="math display">\[
p(y_i = 1 | \boldsymbol{x_i}) = p(\boldsymbol{x_i})
\]</span></p>
<p>그런데 앞서 보았듯이 확률 값을 선형 회귀로 추정하는 데에는 어려움이 있다. 통상적인 회귀 모형의 특성을 유지하면서도 확률 값을 [0,1] 사이에 ‘잘’ 떨구는 일이 무척 귀찮다. 식을 아래와 같이 변형해보도록 하자.</p>
<p><span class="math display">\[
\dfrac{p(\boldsymbol{x_i})}{1-p(\boldsymbol{x_i})}
\]</span></p>
<p>종속 변수를 이렇게 바꾸면 가능한 값의 범위가 <span class="math inline">\([0, \infty)\)</span>로 확장된다. 여기에 자연 로그를 적용해보자.</p>
<p><span class="math display">\[
\ln \dfrac{p(\boldsymbol{x_i})}{1-p(\boldsymbol{x_i})}
\]</span></p>
<p>이제 가능한 값의 범위가 <span class="math inline">\((-\infty, \infty)\)</span>가 된다. 이제 보통의 선형 회귀를 적용해도 좋겠다.</p>
<p>즉,</p>
<p><span class="math display">\[
\ln \dfrac{p(\boldsymbol{x_i})}{1-p(\boldsymbol{x_i})} = \underset{1 \times k}{\phantom{\boldsymbol{\beta}}\boldsymbol{\boldsymbol{x_i}} \phantom{\boldsymbol{\beta}}}\underset{k \times 1}{\boldsymbol{\beta}}, ~k = 1,  2, \dotsc, n
\]</span></p>
<p><span class="math inline">\(n\)</span> 개의 관찰에 있을 때 이를 매트릭스 형태로 적으면 다음과 같다.</p>
<p><span class="math display">\[
\ln \dfrac{p(\boldsymbol{X})}{1-p(\boldsymbol{X})} = \underset{n \times k}{\phantom{\boldsymbol{\beta}}\boldsymbol{X}\phantom{\boldsymbol{\beta}}}\underset{k \times 1}{\boldsymbol{\beta}}
\]</span></p>
<p>애석하지만 이 식은 우리에게 주어진 자료로는 추정할 수 없다. 좌변의 종속 변수를 얻으려면 확률 함수를 알아야 하는데 이 녀석은 영원히 미지의 사실이다. 따라서 위의 식은 선형 회귀를 적용할 수 있는 방법을 고안한 것일 뿐 실제로 추정 가능한 식이 아니다. 그렇다면, <span class="math inline">\(\boldsymbol{\beta}\)</span>는 어떻게 구해야 할까?</p>
<p>이 문제를 살펴 보기 전에 위의 모형에서 로지스틱 함수를 발견해보자. 위의 식에서 <span class="math inline">\(p(x_i)\)</span>를 구해보자.</p>
<p><span class="math display">\[
\begin{aligned}
\ln \dfrac{p(\boldsymbol{x_i})}{1-p(\boldsymbol{x_i})} &amp; =\boldsymbol{x_i}\boldsymbol{\beta} \\
\dfrac{p(\boldsymbol{x_i})}{1-p(\boldsymbol{x_i})}  &amp; = e^{\boldsymbol{x_i}\boldsymbol{\beta}} \\
p(\boldsymbol{x_i}) &amp; = \dfrac{e^{\boldsymbol{x_i}\boldsymbol{\beta}}}{1+e^{\boldsymbol{x_i}\boldsymbol{\beta}}} \\
p(\boldsymbol{x_i}) &amp; = \dfrac{1}{e^{-\boldsymbol{x_i}\boldsymbol{\beta}} + 1}
\end{aligned}
\]</span></p>
<p>앞서 본 그림의 오른쪽과 같은 형태의 로지스틱 함수가 도출된다. 요컨대, 로지스틱 함수는 독립 변수를 해당 사건이 발생할 확률과 연결시키는 장치다. 이렇게 보면 로지스틱 회귀는 이른바 일반 선형 모형(Generalized Linear Model)의 한 사례다. 일반 선형 모형이란 종속 변수, 즉 식의 왼쪽이 어려가지 이유에서 실수 값이 아닌 제한된 값 혹은 범주 값을 지닐 때 이를 여러가지 방법을 통해 실수로 바꾸는 방식으로 추정을 하는 방법이다. 지금까지 살펴본 방법이 그 사례의 하나다.</p>
</section>
</section>
<section id="link-function" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="link-function">Link function</h2>
<p>말이 나온 김에 “링크 함수”를 한번 보고 가자. 위에서 보듯이, 사실 회귀 분석이란 실수의 범위를 지니는 좌변을 역시 변수의 선형결합을 통해 이루어진 우변으로 설명하려는 것이다. 그런데 만일 좌변의 영역이 실수 전체가 아니라면? 예를 들면 아래와 같다.</p>
<ul>
<li>절단 자료 (truncated): 지속 시간의 경우 0보다 큰 실수가 된다.</li>
<li>범주형 자료: 이 경우는 수로 표현하려면 적절한 변형이 필요하다.</li>
<li>정수형 자료</li>
</ul>
<p>이럴 때는 어떻게 해야 할까? 회귀 분석의 틀을 벗어나지 않으면서 가장 간단한 해결책은 좌변을 바꾸는 것이다. 좌변은 어떻게 바꿔야 할까? 우선 좌변에 올 것의 조건부 평균을 다음과 같이 두자. 로지스틱 회귀에서 이 조건부 평균이 해당 상태가 될 , 즉 1의 값을 지닐 확률과 같다.</p>
<p><span class="math display">\[
\mathrm E (y_i | \boldsymbol x_i) =\mu_i
\]</span></p>
<p>그리고 우변의 경우 평범하게 다음과 같이 두자.</p>
<p><span class="math display">\[
\eta_i = \beta_0 + \beta_1 x_{i1}  + \dotsb + \beta_p x_{ip}
\]</span></p>
<p>이 둘은 바로 연결이 안된다. 이 둘을 연결시켜주는 어떤 함수가 있다면? 즉,</p>
<p><span class="math display">\[
g(\mu_i) = \eta_i = \boldsymbol x_i^T \beta
\]</span></p>
<p><span class="math inline">\(g(\cdot)\)</span>이 링크 함수에 해당한다. 로짓 회귀의 경우에는 <span class="math inline">\(\ln \frac{p(x_i)}{1-p(x_i)}\)</span>에 해당한다. 링크 함수의 역함수는 뭐라고 부를까? 로짓 회귀에서 아래의 값에 해당한다.</p>
<p><span class="math display">\[
p(\boldsymbol{x_i}) = \dfrac{1}{e^{-\boldsymbol{x_i}\boldsymbol{\beta}} + 1}
\]</span></p>
<p>이는 평균 함수(mean function)이라고 부른다. 로짓 회귀의 경우는 이산 변수를 활용하기 때문에 확률 질량 함수가 곧 확률이 된다는 점을 기억해두자.</p>
<section id="삼단계" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="삼단계">삼단계</h3>
<p>위 과정이 세 가지 단계를 거쳤다는 점을 쉽게 알 수 있을 것이다.</p>
<p><span class="math display">\[
y_i \xrightarrow{\rm prob.~function} \mu_i \xrightarrow{\rm link~function} \eta_i = \boldsymbol x_i \beta
\]</span></p>
<p>원래 관찰값 <span class="math inline">\(y_i\)</span>는 확률 (질량/밀도) 함수를 통해 <span class="math inline">\(\mu_i\)</span> 로 변형된다. 이는 다시 연결 함수를 통해서 선형 회귀가 가능한 형태로 변형된다.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><span class="math inline">\(y_i\)</span>가 어떤 특성을 지니는지에 따라서 다양한 형태의 <span class="math inline">\(\mu_i\)</span>가 가능하고, 여기에 적절한 연결 함수를 적용해야 한다. 이는 논의 범위를 벗어난다. <a href="https://www.stat.cmu.edu/~ryantibs/advmethods/notes/glm.pdf">이 글</a>을 참고하자.</p>
</div></div></section>
</section>
<section id="계수는-어떻게-구하나" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="계수는-어떻게-구하나">계수는 어떻게 구하나?</h2>
<p><span class="math inline">\(\hat{\boldsymbol \beta}\)</span>은 어떻게 구할 수 있을까? 현재까지 우리에게 주어진 조건을 보자.</p>
<ol type="1">
<li>종속 변수의 관찰값은 0 또는 1이다.</li>
<li>로짓 함수를 통해서 독립 변수를 해당 관찰의 확률과 연결시킬 수 있게 되었다.</li>
</ol>
<p>어차피 종속 변수를 실수로 바꿀 수 없는 이상 우리가 아는 선형 회귀 분석을 쓸 수는 없다. 그래서 이름과 달리 우리가 아는 ‘회귀 분석’, 즉 OLS를 여기서 쓸 수는 없다. 미안하다. 앞에서 거짓말 했다.</p>
<p><span class="math display">\[
\ln \dfrac{p(\boldsymbol{x_i})}{1-p(\boldsymbol{x_i})} = \underset{1 \times k}{\phantom{\boldsymbol{\beta}}\boldsymbol{x_i}\phantom{\boldsymbol{\beta}}}\underset{k \times 1}{\boldsymbol{\beta}}, ~k = 1,  2, \dotsc, n
\]</span></p>
<p>애초에 <span class="math inline">\(\boldsymbol \beta\)</span>을 알고 있어야, 이 식으로부터 <span class="math inline">\(p(\cdot)\)</span>을 구해낼 수 있다. 그런데 우리가 아는 회귀 분석이란 <span class="math inline">\(y\)</span>와 <span class="math inline">\(\boldsymbol{\rm X}\)</span>가 주어졌을 때 하는 것 아닌가? 회귀 분석의 좌변이 없기에 OLS로는 추정할 수 없다.</p>
<p>그래서 로짓 회귀는 이름과 달리 <span class="math inline">\(\boldsymbol{\beta}\)</span>의 추정치 <span class="math inline">\(\hat{\boldsymbol\beta}\)</span>를 구하는데 OLS의 방법을 쓰지 않는다. 로짓 회귀에서는 어떻게 <span class="math inline">\(\hat{\boldsymbol\beta}\)</span>를 얻는 것일까?</p>
<section id="확률-vs-우도" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="확률-vs-우도">확률 vs 우도</h3>
<p>잠시 로짓 회귀의 추정을 살펴보기 전에 확률과 우도의 차이점에 관해서 알아보자. 분포와 그 분포의 파리미터를 알고 있을 때 해당 샘플이 관찰될 확률을 구할 수 있다. 연속 확률변수 <span class="math inline">\(x\)</span>가 따르는 어떤 분포가 있다고 할 때, 해당 분포를 요약하는 파라미터(정규분포라면 평균과 분산이다) <span class="math inline">\(\theta\)</span>에 대해서 <span class="math inline">\(P(x_1 &lt; x &lt;x_2 | \theta)\)</span>를 구한다면, 이것이 확률이다.</p>
<p>우도(likelihood)는 무엇일까? 우도는 확률 분포의 수학적인 형태에서 관심의 대상을 바꾼 것이다. 위의 연속 확률변수의 예에서 <span class="math inline">\(P(\theta | x_1 &lt; x &lt; x_2)\)</span>가 우도가 된다. 하나의 관찰 <span class="math inline">\(x_i\)</span>에 대해서는 확률 밀도함수 <span class="math inline">\(f(\theta | x = x_i)\)</span>를 우도로 정의할 수 있다. 연속 확률변수가 아니라 이산 확률변수라면, 확률 질량함수가 될 것이고 이 경우에는 확률과 같다.</p>
<p>요컨대 주어진 것(conditioning), 즉 무엇을 파라미터로 볼 것인지의 차이에 따라서 확률과 우도의 정의가 달라진다. 다시 정리해보자.</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">명칭</th>
<th style="text-align: center;">주어진 것</th>
<th style="text-align: center;">변수</th>
<th style="text-align: center;">형태</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">확률</td>
<td style="text-align: center;">분포의 파라미터(<span class="math inline">\(\theta\)</span>)</td>
<td style="text-align: center;">관찰값</td>
<td style="text-align: center;"><span class="math inline">\(P(x_1 &lt; x &lt; x_2 | \theta)\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">우도</td>
<td style="text-align: center;">관찰값</td>
<td style="text-align: center;">분포의 파라미터(<span class="math inline">\(\theta\)</span>)</td>
<td style="text-align: center;"><span class="math inline">\(P(\theta|x_1 &lt; x &lt; x_2)\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>

<div class="no-row-height column-margin column-container"><div class="">
<p>연속확률 변수의 경우 하나의 관찰값에 대해서 확률은 이론적으로 정의되지 않지만, 우도는 정의된다. 이 경우 우도는 확률 밀도함수 <span class="math inline">\(f(\theta|x=x_i)\)</span>를 따르게 된다.</p>
</div></div></section>
<section id="최대-우도-추정maximum-likelihood-estimation" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="최대-우도-추정maximum-likelihood-estimation">최대 우도 추정(maximum likelihood estimation)</h3>
<p>다시 문제로 돌아오자. 우리는 0, 1 즉 존재/비존재의 특징을 지니는 변수를 갖고 있다. 그리고 이 녀석은 이산 확률 분포를 따르기 때문에 우도 역시 그냥 확률이 되고, 이는 베르누이 분포를 따른다. 즉, 해당 확률이 발생할 확률 <span class="math inline">\(p\)</span>일 때 발생하면 1, 아니면 0이 된다. 베르누이 분포의 확률 질량 함수를 간단하게 표현하는 방법은 없을까?</p>
<p><span class="math display">\[
L(y_i) = p(\boldsymbol{x_i}; \boldsymbol{\beta})^{y_i} (1-p(\boldsymbol{x_i}; \boldsymbol{\beta}))^{1-y_i}
\]</span></p>
<p>위와 같은 식으로 간단히 해결된다. 위 식에서 <span class="math inline">\(y_i\)</span>가 1이면 <span class="math inline">\(p(\cdot)\)</span>가, 0이면 <span class="math inline">\(1-p(\cdot)\)</span>가 할당된다. 이제 우리는 <span class="math inline">\(n\)</span> 개의 관찰에 관해서 식의 좌변에는 0,1을 갖고 있다. 각각의 시행이 독립적이라고 가정하면 주어진 형태의 데이터를 관찰하게 될 우도는 이 확률을 곱한 것과 같다. 즉,</p>
<p><span class="math display">\[
L(y|{\boldsymbol X}) = \prod_{i = 1}^{n}  L(y_i) = \prod p(\boldsymbol{x_i}; \boldsymbol{\beta})^{y_i} (1-p(\boldsymbol{x_i}; \boldsymbol{\beta}))^{1-y_i} = L(\boldsymbol{\beta}|y, {\boldsymbol X})
\]</span></p>
<p><span class="math inline">\(\boldsymbol{\beta}\)</span>에 따라서 우도가 달라지게 되므로 우도 함수가 일종의 목적 함수가 된다. 우도를 극대화해주는 <span class="math inline">\(\boldsymbol{\beta}\)</span>가 최대 우도 추정치, 즉 MLE(MLE, maximum likelihood estimator) <span class="math inline">\(\hat{\boldsymbol\beta}\)</span> 이다. 즉,</p>
<p><span class="math display">\[
\hat {\boldsymbol \beta} = \text{arg max }{L({\boldsymbol \beta}|y, {\boldsymbol X})}
\]</span></p>

<div class="no-row-height column-margin column-container"><div class="">
<p>간혹 목적 함수, 즉 우도 함수가 비선형이라서 목적 함수의 최대화를 달성하는 해 <span class="math inline">\(\hat{\boldsymbol\beta}\)</span>를 축약형(reduced form)으로 구하기 힘들다는 내용을 접하곤 한다. 이는 반쪽만 맞다. 반례로 선형 회귀 모형에서 에러 항이 정규 분포를 따른다고 가정하면 최대 우도 추정을 적용할 수 있다. 정규 분포의 우도 역시 비선형이지만, 축약형 해를 쉽게 구할 수 있다. 이때 MLE <span class="math inline">\(\hat{\boldsymbol\beta}\)</span>은 통상적인 방법으로 구한 OLS 추정량와 동일하다. 본문에서 말했듯이, 이는 수치적인 방법이 아니라 분석적인 방법을 통해 축약형으로 도출 가능하다. <a href="https://en.wikipedia.org/wiki/Proofs_involving_ordinary_least_squares#Maximum_likelihood_approach">여기</a>를 참고하라. 왜 로짓 회귀에서는 축약형 해를 구할 수 없을까? 우도 추정에서 우리가 관심이 있는 것은 목적함수를 극대화하는 <span class="math inline">\(\hat{\boldsymbol\beta}\)</span> 값이지 우도 자체가 아니다. 따라서 원래의 우도를 적절한 형태로 변형해도 변형된 목적함수를 극대화해주는 <span class="math inline">\(\hat{\boldsymbol\beta}\)</span>가 바뀌지 않는다면 목적 함수를 변형해도 괜찮다. 때로는 변형이 계산을 쉽게 바꿔준다. 정규분포는 오일러 수(<span class="math inline">\(e\)</span>)의 지수 위에 최적화에 필요한 파라미터가 모두 포함되어 있다. 따라서 원래 목적함수에 <span class="math inline">\(\ln(\log_e)\)</span>를 취하면 곱셈이 덧셈으로 변하고 <span class="math inline">\(e\)</span> 위에 지수로 올라가 있단 파라미터들이 앞으로 내려온다. 하지만 아래 식에서 보듯이 로짓 함수는 그렇지 않다.</p>
<p><span class="math display">\[
p(\boldsymbol{x_i})  = \dfrac{1}{e^{-\boldsymbol{\boldsymbol{x_i}}\boldsymbol{\beta}} + 1}
\]</span></p>
<p>이 함수에 <span class="math inline">\(\ln\)</span>을 취한다고 해서 식이 단순해지지 않는다. 로짓 함수의 경우 우도 극대화에서 축약형을 해를 구할 수 있는 변형이 없기 때문에 해당 우도를 극대화하는 파라미터를 찾기 위해서는 수치 최적화(numerical optimization)를 활용한다. 수치 최적화의 자세한 내용과 사례는 <a href="https://ratsgo.github.io/machine%20learning/2017/07/02/logistic/">이 글</a>을 참고하라.</p>
</div></div></section>
<section id="계수의-의미는" class="level3">
<h3 class="anchored" data-anchor-id="계수의-의미는">계수의 의미는?</h3>
<p>보통 기계 학습의 맥락에서 로짓 회귀는 가장 원시적인 분류기(classifier)로 소개된다. 즉 <span class="math inline">\(y_i\)</span>의 속성을 예측하는 분류 장치이기 때문에 <span class="math inline">\(\hat{\boldsymbol\beta}\)</span>에 특별한 의미를 부여하지 않는다. 하지만 회귀 분석을 인과관계의 추론의 활용해 온 여타 분야에서는 <span class="math inline">\(\hat{\boldsymbol\beta}\)</span>를 어떻게 해석할 것인지는 중요한 질문이다.</p>
<p>먼저 OLS의 경우 변수를 어떻게 변형했는지에 따라서 다르지만, 대체적으로 <span class="math inline">\(\beta_i\)</span>는 해당 독립 변수 <span class="math inline">\(x_i\)</span>의 한계 효과(marginal effect)로 해석할 수 있다. 즉, <span class="math inline">\(x_i\)</span>가 한 단위 변할 때 이에 따른 <span class="math inline">\(y_i\)</span>의 변화량을 의미한다. 그런데, 로짓 회귀에서는 이렇게 해석할 수 없다. 앞서 보았듯이, 로짓 회귀의 추정식은 다음과 같다.</p>
<p><span class="math display">\[
\ln \dfrac{p(\boldsymbol{x_i})}{1-p(\boldsymbol{x_i})} = \underset{1 \times k}{\phantom{\boldsymbol{\beta}}\boldsymbol{\boldsymbol{x_i}}\phantom{\boldsymbol{\beta}}}\underset{k \times 1}{\boldsymbol{\beta}}, ~k = 1,  2, \dotsc, n
\]</span></p>
<p>흔히 좌변의 <span class="math inline">\(\dfrac{p(\boldsymbol{x_i})}{1-p(\boldsymbol{x_i})}\)</span>를 오즈(odds) 혹은 승산(勝計)이라고 부른다. 이때 <span class="math inline">\(\boldsymbol{\beta} = [\beta_1, \dotsc, \beta_j, \dotsc, \beta_k]\)</span>에서 <span class="math inline">\(\beta_j\)</span>는 독립 변수의 벡터 <span class="math inline">\(\boldsymbol{x_i}\)</span>에 속한 <span class="math inline">\(x_j\)</span> 한 단위가 변할 때 오즈에 미치는 영향을 뜻한다.</p>
<p>간혹 <span class="math inline">\(\beta_i\)</span>를 좌변의 상태를 변화시킬 확률의 변화로 해석하는 경우가 있는데 그렇게 하면 안된다. <span class="math inline">\(x_i\)</span>의 변화가 상태를 0에서 1로 바꾸는 데 미치는 확률에 관심이 있다면, 아래의 두 가지에 유의하자.</p>
<ol type="1">
<li>OLS의 경우 회귀식 자체가 선형이기 때문에 <span class="math inline">\(\beta_i\)</span>에 관한 해석이 쉽고 단순하다. 그냥 직선의 기울기다. 그런데 로짓 회귀에서는 그렇게 분명하지 않다. 추정하려는 식 자체가 비선형이므로 한계 효과를 구하기 위한 기울기를 ‘어디서’ 구할지가 문제가 된다. 측정 위치에 따라서 기울기가 달라지기 때문이다.</li>
<li>도출하는 방법이 크게 어렵지는 않다. 측정에는 대체로 두 가지 방식이 많이 활용된다. 독립 변수 <span class="math inline">\(x_i\)</span> 관찰값 별로 확률값의 변화를 추정한 뒤 이를 평균하는 방식이다. 반대로 독립 변수 값의 평균에서 한번만 <span class="math inline">\(p_i\)</span>에 미치는 영향을 추정하는 방법이다. 통계 패키지가 대체로 두 방법을 모두 지원하니 필요할 경우 찾아서 값을 구하면 되겠다. 해석과 보고 시에는 역시 주의해야 한다. 만일 첫번째 방법으로 수행했다면, <span class="math inline">\(x_i\)</span>의 1단위 변화가 평균적으로 확률에 미치는 영향으로 표현하는 게 비교적 오해를 덜 살 것이다.</li>
</ol>
</section>
<section id="계수의-수학적인-이해" class="level3">
<h3 class="anchored" data-anchor-id="계수의-수학적인-이해">계수의 수학적인 이해</h3>
<p>이 부분이 부담스럽다면 넘어가도 좋다. 앞서 말한 한계 효과는 <span class="math inline">\(\frac{\partial p}{\partial x_j}\)</span>이다. 즉, 독립 변수 벡터의 한 변수<span class="math inline">\(x_j\)</span> 가 한 단위 변할 때 확률 변화를 측정한다. 즉,</p>
<p><span class="math display">\[
p(\boldsymbol{x_i}) = \dfrac{1}{e^{-\boldsymbol{x_i}\boldsymbol{\beta}} + 1}
\]</span></p>
<p>이 녀석을 그대로 미분해보자. 먼저 아래와 같이 <span class="math inline">\(p(\cdot)\)</span>을 변형하자.</p>
<p><span class="math display">\[
\begin{aligned}
p(\boldsymbol{x_i}) &amp; = \dfrac{1}{e^{-\boldsymbol{x_i}\boldsymbol{\beta}} + 1} \\
&amp; = \dfrac{e^{\boldsymbol{x_i}\boldsymbol{\beta}}}{1 + e^{\boldsymbol{x_i}\boldsymbol{\beta}}}
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\boldsymbol x_i = [x^1, \dotsc, x^k]\)</span>이고, <span class="math inline">\(x^j\)</span>에 대해서 미분하면 아래와 같다.</p>
<p><span class="math display">\[
\dfrac{\partial p(\boldsymbol{x_i})}{\partial x^j} = \dfrac{\beta_j e^{\boldsymbol{x_i}\boldsymbol{\beta}}}{(e^{\boldsymbol{x_i}\boldsymbol{\beta}} + 1)^2}
\]</span></p>
<p>이처럼 한계 효과는 미분을 통해 간단히 도출할 수 있다. 앞서 말했던 두 가지 측정을 어떻게 구별할 수 있을지 다시 살펴보자.</p>
<p><span class="math inline">\(\boldsymbol{\beta}\)</span>의 추정치로 MLE를 통해 구한 <span class="math inline">\(\hat{\boldsymbol\beta}\)</span>를 활용한다고 해도, 어떤 <span class="math inline">\(\boldsymbol{x_i}\)</span>에서 측정하는지에 따라서 값이 달라진다. 평균(marginal effect at mean)에서 한 번만 측정할 것인지 아니면 <span class="math inline">\(n\)</span>개의 모든 데이터 포인트에 대해서 계산한 뒤 이를 평균(average marginal effect)할 것인지 등의 선택이 필요하다. 보통 후자를 많이 활용하는데, 통계 패키지마다 둘 모두를 구할 수 있는 옵션을 제공한다.</p>


<div class="hidden" aria-hidden="true">
<span class="glightbox-desc lightbox-desc-1">로지스틱 리그레션이 필요한 순간</span>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/www\.lostineconomics\.com\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"selector":".lightbox","loop":false,"descPosition":"bottom","openEffect":"zoom","closeEffect":"zoom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>