<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="JS HUHH">
<meta name="dcterms.date" content="2022-05-27">
<meta name="description" content="기본 용어 정리한다.">

<title>lostineconomics.com - Sample Statistics and Standard Error</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">lostineconomics.com</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../project.html"> 
<span class="menu-text">project</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/anarinsk"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/anarinsk"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Sample Statistics and Standard Error</h1>
  <div class="quarto-categories">
    <div class="quarto-category">statistics</div>
    <div class="quarto-category">stats-simple</div>
  </div>
  </div>

<div>
  <div class="description">
    기본 용어 정리한다.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>JS HUHH </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 27, 2022</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-JNRF3S74Z4"></script><div class="hidden">
<p><span class="math display">\[
\def\E{{\mathbb E}}
\def\V{{\mathbb V}}
\def\ES#1{\overline{#1}}
\]</span></p>
</div>
<section id="tl-dr" class="level2">
<h2 class="anchored" data-anchor-id="tl-dr">TL; DR</h2>
<ul>
<li>기본 통계학 용어와 개념 몇 개를 두서없이 내 맘대로 정리한다.</li>
<li>자주 잊는 나를 위한 개인적인 용도</li>
</ul>
</section>
<section id="why" class="level2">
<h2 class="anchored" data-anchor-id="why">Why</h2>
<p>통계학을 배운 사람들이라면 표준 오차는 대체로 잘 아는 내용이다. 그런데 나는 가끔 까먹는다. 개인적인 용도를 위해서 관련된 앞뒤 내용 몇 가지를 순서 없이 정리해둔다.</p>
</section>
<section id="big-ifs" class="level2">
<h2 class="anchored" data-anchor-id="big-ifs">Big Ifs</h2>
<ul>
<li>알려진 파라미터는 없다.</li>
<li>알려진 분포도 없다.</li>
<li>표본은 평균이 <span class="math inline">\(\mu\)</span>이고 분산이 <span class="math inline">\(\sigma^2 &lt; \infty\)</span>인 분포에서 IID(independent and identically distributed)로 추출된다.</li>
</ul>
</section>
<section id="finite-sample-vs-asymptotic-properties" class="level2">
<h2 class="anchored" data-anchor-id="finite-sample-vs-asymptotic-properties">Finite Sample vs Asymptotic Properties</h2>
<p>“유한 표본 finite sample”이란 어떤 크기든 표본의 크기가 정해져 있다는 의미이다. 가끔 “소 표본 small sample”이라는 표현도 활용된다. “점근적 특성 asymptotic properties”이란 표본 크기가 계속 커질 때 추정량이 지니는 특성을 의미한다. 통계학을 배울 때는 유한 표본의 추정량(estimator)에 관해 먼저 엄밀하게 배운다. 통계학을 활용한다는 실용적인 관점에서 중요한 것은 추정량의 점근적 특징이다.</p>
<p>점근성에 관해서 두 가지를 짚고 가자. 일치성은 샘플의 크기가 커질수록 추정량이 모수에 접근하는 특징이다. 다른 하나는 중심 극한 정리(central limit theorem)이다. 샘플의 크기가 커질수록 추정량의 분포가 정규 분포에 접근하게 된다. 일치성이 확보되면 추정량이 불편성을 지니고 있지 않아도 표본의 크기가 커질수록 참값에 충분히 가깝게 접근한다. 한편 중심 극한 정리는 추정량의 통계적인 검정을 위한 매우 중요한 방법을 제공한다. 아래에서 다시 살펴보기로 하자.</p>
</section>
<section id="unbiasedness-efficiency-consistency" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="unbiasedness-efficiency-consistency">Unbiasedness, Efficiency, Consistency</h2>
<p>파라미터 <span class="math inline">\(\theta\)</span>와 이 모수에 관한 추정량 <span class="math inline">\(\hat \theta\)</span>이 있다고 하자.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>표본 <span class="math inline">\(x_i\)</span>가 있다고 할 때, <span class="math inline">\(\hat \theta\)</span>는 표본 <span class="math inline">\(x_i\)</span>라는 정보를 통해 구성된다. 즉, <span class="math inline">\(\hat\theta \equiv \hat\theta(x_i)\)</span>.</p>
</div></div><p><strong>Unbiased</strong> <span class="math display">\[
\E(\hat \theta) = \theta
\]</span></p>
<p>불편성은 추정량의 중요한 특징이지만, 불편성만으로 충분하지 않다. 극단적인 예로 <span class="math inline">\(X\)</span>에서 추출된 샘플 하나를 <span class="math inline">\(x_1\)</span>라고 하자. 이 샘플 하나를 추정량으로 쓰면 이 역시 불편성을 지니고 있다 (<span class="math inline">\(\E(x_1) = \theta\)</span>). 하지만 이 추정량은 좋은 추정량이 아니다.</p>
<p><strong>Efficiency</strong></p>
<p><span class="math inline">\(\theta\)</span>에 대해서 <span class="math inline">\(\hat \theta_1\)</span>과 <span class="math inline">\(\hat \theta_2\)</span> 두 개의 추정량이 있다고 하자. <span class="math display">\[
\rm{Var} (\hat\theta_1) \leq \rm{Var} (\hat\theta_2)
\]</span></p>
<p>모든 <span class="math inline">\(\theta\)</span>에 대해서 위의 부등식이 성립하고, 적어도 하나의 <span class="math inline">\(\theta\)</span>에 대해서 강 부등호가 성립하면 <span class="math inline">\(\hat\theta_1\)</span>이 <span class="math inline">\(\hat\theta_2\)</span>보다 효율적이다.</p>
<p><strong>Consistent</strong></p>
<p>표본의 크기에 따른 추정량의 시퀀스 <span class="math inline">\(\lbrace \hat\theta_n \rbrace\)</span>이 있다고 할 때, <span class="math display">\[
\underset{n \to \infty}{\rm plim}~\hat\theta_n = \theta  
\]</span></p>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[[-10, 60, -10]]">
<div class="quarto-layout-row quarto-layout-valign-bottom">
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 12.5%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 75.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://upload.wikimedia.org/wikipedia/commons/b/b2/Consistency_of_estimator.svg" class="lightbox" data-glightbox="description: .lightbox-desc-1" data-gallery="quarto-lightbox-gallery-1" title="파라미터 값 4를 추정하기 위한 샘플 추정량; 샘플 크기가 증가하면서 4로 접근한다. 예시의 샘플 추정량은 biased된 추정량이다."><img src="https://upload.wikimedia.org/wikipedia/commons/b/b2/Consistency_of_estimator.svg" class="img-fluid figure-img" alt="파라미터 값 4를 추정하기 위한 샘플 추정량; 샘플 크기가 증가하면서 4로 접근한다. 예시의 샘플 추정량은 biased된 추정량이다."></a></p>
<figcaption>파라미터 값 4를 추정하기 위한 샘플 추정량; 샘플 크기가 증가하면서 4로 접근한다. 예시의 샘플 추정량은 biased된 추정량이다.</figcaption>
</figure>
</div>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 12.5%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
</div>
</div>

<div class="no-row-height column-margin column-container"><div class="">
<p>plim의 정의는 다음과 같다. 표본 크기 <span class="math inline">\(n\)</span>과 임의의 양의 상수 <span class="math inline">\(c\)</span>에 대하여 표본 추정량 <span class="math inline">\(\hat\theta_n\)</span>은 <span class="math inline">\(\theta\)</span>의 일치 추정량(consistent estimator)이라고 한다.</p>
<p><span class="math display">\[
\lim_{n\to\infty}P[|\hat\theta_n - \theta|\geq c]=0
\]</span></p>
</div></div></section>
<section id="concepts" class="level2">
<h2 class="anchored" data-anchor-id="concepts">Concepts</h2>
<table class="table">
<colgroup>
<col style="width: 40%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">용어</th>
<th>영어 표현</th>
<th>정의</th>
<th>사례 혹은 코멘트</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">모수</td>
<td>parameter</td>
<td>한 모집단의 고정된 특성 혹은 이를 나타내는 값</td>
<td><span class="math inline">\(\E[Y_i]\)</span>, 분포의 <span class="math inline">\(\mu\)</span>, <span class="math inline">\(\sigma^2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">표본 통계량</td>
<td>sample statistics</td>
<td>표본에 따라서 변화하는 값</td>
<td><span class="math inline">\(\ES{Y}_n\)</span>, <span class="math inline">\(S(Y_i)^2\)</span>, <span class="math inline">\(SE\)</span>, <span class="math inline">\(\widehat{SE}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">표본 평균</td>
<td>sample mean</td>
<td>표본의 평균</td>
<td><span class="math inline">\(\ES{Y}_n = \frac{1}{n}\sum_{i=1}^n Y_i\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">표본 분산</td>
<td>sample variance</td>
<td>표본의 분산</td>
<td><span class="math inline">\(S(Y_i)^2 = \frac{1}{n-1}\sum_{i=1}^n (Y_i - \ES{Y}_n)^2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">표준 오차</td>
<td>standard error</td>
<td>표본 통계량의 표준 편차</td>
<td><span class="math inline">\(SE(\ES{Y}_n) = \frac{\sigma_Y}{\sqrt{n}}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">표준 오차의 추정치</td>
<td>estimated standard error</td>
<td>표준 오차 계산 시 <span class="math inline">\(\sigma_Y \to S(Y_i)\)</span></td>
<td><span class="math inline">\(\widehat{SE}(\ES{Y}_n) = \frac{S(Y_i)}{\sqrt{n}}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(t-\)</span>통계량</td>
<td><span class="math inline">\(t-\)</span>statistic</td>
<td><span class="math inline">\(t(\mu) = \frac{\ES{Y}_n - \mu}{\widehat{SE}(\ES{Y}_n)}\)</span></td>
<td><span class="math inline">\(n\)</span>이 커질 때 정규분포에 근접</td>
</tr>
</tbody>
</table>
</section>
<section id="sample-mean" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sample-mean">Sample Mean</h2>
<p>IID 추출로 크기 <span class="math inline">\(n\)</span>의 표본 <span class="math inline">\(Y_1, \dotsc, Y_n\)</span>을 얻었다고 하자. <span class="math inline">\(Y_i\)</span>가 모평균 <span class="math inline">\(\mu\)</span>와 모 표준편차 <span class="math inline">\(\sigma\)</span>를 따른다. 표본 평균의 정의는 다음과 같다.</p>
<p><span class="math display">\[
\ES{Y}_n = \sum_{i=1}^n Y_i.
\]</span></p>
<p>표본 평균과 달리 <span class="math inline">\(Y_i\)</span>의 기댓값, 즉 모평균은 <span class="math inline">\(\E (Y_i) \equiv \mu\)</span>라고 쓴다. 여기는 <span class="math inline">\(n\)</span>이 붙지 않는다. 이는 모평균의 특성으로 일종의 고정된 (미지의) 값이다. 기댓값 <span class="math inline">\(\E(Y_i)\)</span>를 추정하는 값으로서 표본 평균 <span class="math inline">\(\ES{Y}_n\)</span>의 세 가지 특징을 알아보자.</p>
<ol type="1">
<li><span class="math inline">\(\E(\ES Y_n) = \mu\)</span></li>
<li><span class="math inline">\(\V(\ES Y_n) = {\sigma^2}/{n}\)</span></li>
</ol>
<section id="unbiasedness" class="level3">
<h3 class="anchored" data-anchor-id="unbiasedness">Unbiasedness</h3>
<p>1에서 보듯이 <span class="math inline">\(\ES{Y}_n\)</span>은 불편 추정량이다.</p>
</section>
<section id="consistency" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="consistency">Consistency</h3>
<p><span class="math inline">\(n\)</span>이 증가하면 LLN에 따라서 <span class="math inline">\(\ES{Y}_n \overset{P}{\longrightarrow} \mu\)</span>가 성립한다.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><span class="math inline">\(\overset{P}{\longrightarrow}\)</span>는 확률적인 수렴, 즉 앞서 정의를 살펴본 probability limit을 뜻한다. LLN은 약한 버전과 강한 버전이 있다. Kolmogorov의 강한 버전은 증명이 복잡하다. 약한 버전의 증명은 <a href="https://python.quantecon.org/lln_clt.html">여기</a>를 참고하자. Chebyshev 부등식과 <span class="math inline">\(\lim_{n \to \infty} \V(\ES{Y}_n) = 0\)</span>을 활용한다.</p>
</div></div></section>
<section id="central-limit-theorem" class="level3">
<h3 class="anchored" data-anchor-id="central-limit-theorem">Central Limit Theorem</h3>
<p><span class="math display">\[
Z_n = \lim_{n \to \infty} \dfrac{\ES{Y}_n - \mu}{\frac{\sigma}{\sqrt{n}}} \sim \rm N(0,1)
\]</span></p>
</section>
</section>
<section id="sample-variance" class="level2">
<h2 class="anchored" data-anchor-id="sample-variance">Sample Variance</h2>
<p><span class="math inline">\(\sigma\)</span>의 추정량인 표본 분산 <span class="math inline">\(S_n\)</span>는 다음과 같다.</p>
<p><span class="math display">\[
S^2_n = \dfrac{1}{n-1} \sum_{i=1}^{n} (Y_i - \ES{Y}_n)^2
\]</span></p>
<p><span class="math inline">\(S^2_n\)</span>은 <a href="#s2-n-1">불편 추정량</a>이고 <a href="#s2-consistent">일치 추정량</a>이다. <span class="math inline">\(n\)</span>이 충분히 크다면 불편 추정량 여부는 중요하지 않다. <span class="math inline">\(\dfrac{1}{10000}\)</span>과 <span class="math inline">\(\dfrac{1}{9999}\)</span>의 차이가 큰 의미가 있을까? 분모의 <span class="math inline">\((n-1)\)</span> 대신 <span class="math inline">\(n\)</span>이 들어간 표본 추정량 역시 일치성을 지니고 있다.</p>
</section>
<section id="standard-errorse" class="level2">
<h2 class="anchored" data-anchor-id="standard-errorse">Standard Error(SE)</h2>
<p>어떤 통계량의 표준 오차(Standard Error)는 표본 통계량의 표준 편차를 뜻한다. 표본 통계량 <span class="math inline">\(\ES{Y}_n\)</span>의 표준 편차 <span class="math inline">\(\sqrt{\V(\ES{Y}_n)}\)</span>을 의미한다. <span class="math inline">\(\sigma^2 &lt; \infty\)</span>를 가정할 때,</p>
<p><span class="math display">\[
\E(\ES{Y}_n - \mu)^2 = \E (\dfrac{\sum(Y_i -\mu)}{n})^2 = \dfrac{1}{n^2} n \sigma^2 = \dfrac{\sigma^2}{n}
\]</span></p>
<p>표준오차 SE는 다음과 같다.</p>
<p><span class="math display">\[
SE = \dfrac{\sigma}{\sqrt{n}}
\]</span></p>
<p><span class="math inline">\(SE\)</span>의 추정량 <span class="math inline">\(\widehat{SE}\)</span>는 <span class="math inline">\(\sigma\)</span> 대신 <span class="math inline">\(S_n\)</span>을 사용한다.</p>
<p><span class="math display">\[
\widehat{SE} = \dfrac{S_n}{\sqrt{n}}
\]</span></p>
</section>
<section id="asymptotically-normal" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="asymptotically-normal">Asymptotically Normal!</h2>
<p>가설 검정에 활용하는 <span class="math inline">\(t-\)</span>통계량이 정규 분포에 근사하는 이유는 무엇일까?</p>
<p><span class="math display">\[
t(\mu) = \frac{\overline{Y}-\mu}{\widehat{SE}(\overline{Y})}
\]</span></p>
<p><span class="math inline">\(t-\)</span>통계량의 분자와 분모를 살펴보면 각각 <span class="math inline">\(n\)</span>이 커질 때 분자와 분모는 모두 0으로 수렴한다. 이 비율이 정규분포에 수렴한다는 사실은 중심극한 정리를 이용해 증명할 수 있다. 일단 결론만 기억하도록 하자. 요컨대 <span class="math inline">\(t\)</span>-통계량은 표본 크기 <span class="math inline">\(n\)</span>이 증가하면서 표준 정규 분포에 근사하게 된다. 다시 말하면 추정량 <span class="math inline">\(\ES{Y}_n\)</span>은 평균이 <span class="math inline">\(\mu\)</span>이고 표준편차가 <span class="math inline">\(\frac{\sigma}{\sqrt{n}}\)</span>인 정규 분포에 근사하게 된다.</p>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[[-10, 60, -10]]">
<div class="quarto-layout-row quarto-layout-valign-bottom">
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 12.5%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 75.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://miro.medium.com/max/1400/0*V1zCLq5mboTCfq2_.jpeg" class="lightbox" data-glightbox="description: .lightbox-desc-2" data-gallery="quarto-lightbox-gallery-2" title="n이 커질수록 \ES{X}_n의 분포는 표준 정규 분포에 근접한다. x_i가 추출된 모집단의 분포를 찾는 것이 아니다. 우리에게 중요한 것은 추정량 \ES{X}_n이고 이 녀석의 분포를 묘사하는 것이 CLT이다."><img src="https://miro.medium.com/max/1400/0*V1zCLq5mboTCfq2_.jpeg" class="img-fluid figure-img" alt="n이 커질수록 \ES{X}_n의 분포는 표준 정규 분포에 근접한다. x_i가 추출된 모집단의 분포를 찾는 것이 아니다. 우리에게 중요한 것은 추정량 \ES{X}_n이고 이 녀석의 분포를 묘사하는 것이 CLT이다."></a></p>
<figcaption><span class="math inline">\(n\)</span>이 커질수록 <span class="math inline">\(\ES{X}_n\)</span>의 분포는 표준 정규 분포에 근접한다. <span class="math inline">\(x_i\)</span>가 추출된 모집단의 분포를 찾는 것이 아니다. 우리에게 중요한 것은 추정량 <span class="math inline">\(\ES{X}_n\)</span>이고 이 녀석의 분포를 묘사하는 것이 CLT이다.</figcaption>
</figure>
</div>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 12.5%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
</div>
</div>
<p><span class="math inline">\(t-\)</span>통계량은 대 표본(large sample)의 통계적 검정에 기둥이다. 원래 자료가 어느 분포에서 나왔는지와 관계없이 표본 통계량을 활용하는 <span class="math inline">\(t-\)</span>통계량은 정규 분포를 따르게 되고 이를 통해 가설 검정을 실시할 수 있다.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>회귀 분석의 검정 또한 <span class="math inline">\(t-\)</span>통계량에 근거한다. <a href="#regression-$t-$statistic">여기</a>를 참고하도록 하자.</p>
</div></div></section>
<section id="t-값은-해당-통계량의-통계적인-증거일-뿐이다" class="level2">
<h2 class="anchored" data-anchor-id="t-값은-해당-통계량의-통계적인-증거일-뿐이다"><span class="math inline">\(t\)</span>-값은 해당 통계량의 ‘통계적인’ 증거일 뿐이다</h2>
<p><span class="math inline">\(t-\)</span>통계량의 크기는 검정을 위한 통계학적 증거일 뿐이다. 이 점을 잊지 말자. <span class="math inline">\(t-\)</span>통계량의 형태에서 보듯이 분자가 충분히 크거나 혹은 분모가 충분히 작을 때 이 값이 커진다. 이는 신뢰 구간에 대해서도 마찬가지다. 신뢰 구간은 표준 오차에 반영되어 있는 통계적 정밀성에 의해 결정되지 우리가 발견하고자 하는 관계의 내용상 강도에 의해서 결정되지 않는다. 즉 <span class="math inline">\(t-\)</span>통계량 및 신뢰 구간의 모습을 보고 해당 독립 변수가 종속 변수에 미치는 효과의 강도로 오해하면 곤란하다.</p>
<p>울드리지 교수는 이를 통계적 유의성과 실용적 유의성의 차이로 설명한다. 통계적으로 유의미한 변수를 찾으면 우리는 대체로 기분이 좋아진다. 하지만 통계적으로 유의한 그 관계가 실용적으로도 그럴까? 만일 통계적 유의성을 지닌 계수가 사실상 의미가 없는 경우라면 어떨까? 책을 읽을 때 다리를 떨면 책을 읽는 속도가 통계적으로 유의미하게 0.1% 증가한다고 하자. 이는 사실상 의미 있는 결과일까? (책을 읽을 때는 열심히 다리를 떨어라?)</p>
</section>
<section id="more" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="more">More</h2>
<p>이하의 내용은 딱히 필요하지는 않다. 관심이 있는 경우는 살펴보면 좋겠다.</p>
<section id="s2-n-1" class="level3">
<h3 class="anchored" data-anchor-id="s2-n-1"><span class="math inline">\(S^2\)</span>을 <span class="math inline">\((n-1)\)</span>로 나누는 이유</h3>
<p><span class="math inline">\(S^2\)</span>의 분모에 왜 <span class="math inline">\((n-1)\)</span>이 들어갈까? 불편 추정량을 얻기 위해서다. 불편 추정량이란 해당 통계치의 기댓값이 모수가 되는 추정량을 의미한다. 직접 <span class="math inline">\(S^2\)</span>의 기댓값을 구해보자. 먼저,</p>
<p><span class="math display">\[
\begin{aligned}
\sigma^2 = {\rm Var}(x_i) &amp; = \mathbb E[(x_i - \mu)^2] \\
&amp; = \mathbb E [x_i^2 - 2 x_i \mu + \mu^2] \\
&amp; = \mathbb E(x_i^2) - 2\mu E(x_i) + \mu^2 \\
&amp; =  \mathbb E(x_i^2) - \mu^2
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\mathbb E(x_i^2) = \sigma^2 + \mu^2\)</span> 임을 기억해두자.</p>
<p>이제 <span class="math inline">\(S^2\)</span>의 기댓값을 구해보자. 분자 먼저 계산하자.</p>
<p><span class="math display">\[
\begin{aligned}
\mathbb E[\sum(x_i - \overline{x})^2] &amp; = \mathbb E[\sum (x_i^2 - 2 x_i \overline{x} + \overline{x}^2)] \\
&amp; = \mathbb E[\sum x_i^2 - n 2 \overline{x} \cdot \overline{x} + n \overline{x}^2] \\
&amp; = \mathbb E[\sum x_i^2 - n \overline{x}^2)] \\
&amp; = \sum \mathbb E(x_i^2) - n \mathbb E(\overline{x}^2)
\end{aligned}
\]</span></p>
<p>합해지는 부분의 각각을 따져보자.</p>
<p><span class="math display">\[
\begin{aligned}
\sum \mathbb E(x_i^2) = n (\sigma^2 + \mu^2)
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\mathbb E(\overline{x}^2) &amp; = \mathbb E[(\dfrac{x_1 + x_2 + \dotsb + x_n}{n})^2] \\
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(\mathbb E[(\dfrac{x_1 + x_2 + \dotsb + x_n}{n})^2]\)</span>의 분자를 계산하면 된다. 먼저 각 <span class="math inline">\(x_i\)</span>의 제곱이 <span class="math inline">\(n\)</span>개 나온다. 다음으로 각각 <span class="math inline">\(x_i\)</span>가 독립적으로 추출되었으므로 <span class="math inline">\(i \neq j\)</span>일 때 <span class="math inline">\(\mathbb E(x_i x_j) = \mathbb E(x_i) \mathbb E(x_j) = \mu^2\)</span>이 된다. <span class="math inline">\(n\)</span> 개 중에서 2개를 순서에 관계없이 뽑게 된다. 즉,</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\mathbb E[(x_1 + x_2 + \dotsb + x_n)^2]  &amp; = n (\sigma^2 + \mu^2) + 2 \dfrac{n(n-1)}{2!} \mu^2 \\
&amp; = n \sigma^2 + n^2 \mu^2
\end{aligned}
\]</span></p>
<p>따라서,</p>
<p><span class="math display">\[
\mathbb E(\overline{x}^2)  = \dfrac{\sigma^2}{n} + \mu^2
\]</span></p>
<p>이제 각각을 넣어 계산을 완료하자.</p>
<p><span class="math display">\[
\begin{aligned}
\mathbb E[\sum(x_i - \overline{x})^2] &amp; = \sum \mathbb E(x_i^2) - n \mathbb E(\overline{x}^2) \\
&amp; = n \sigma^2 + n \mu^2 - \sigma^2 - n \mu^2 \\
&amp; = (n-1) \sigma^2
\end{aligned}
\]</span></p>
<p>따라서 불편 추정량이 되기 위해서는 <span class="math inline">\(S^2\)</span>의 분모에 <span class="math inline">\((n-1)\)</span>이 필요하다.</p>
</section>
<section id="s2-consistent" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="s2-consistent"><span class="math inline">\(S^2_n\)</span>의 일치성</h3>
<p><span class="math inline">\(S^2\)</span>의 일치성을 증명하는 데 필요한 내용을 알아보자. 엄밀한 증명은 생략하고 간략하게 아이디어만 적도록 하겠다. <span class="math inline">\(\sigma &lt; \infty\)</span>를 가정하자. 이때</p>
<p><span class="math display">\[
\begin{aligned}
S_n^2 &amp; = \dfrac{1}{n-1}\sum_{i=1}^n (X_i - \overline{X}_n) \\
&amp; = \dfrac{n}{n-1}(\dfrac{\sum X_i^2}{n} - \overline X_n) \\
&amp; \stackrel{P}{\longrightarrow} 1\cdot(\E(X^2)-\mu^2) = \sigma^2
\end{aligned}
\]</span></p>
<p>위에서 보듯이 <span class="math inline">\(S^2_n\)</span>이든 <span class="math inline">\(\dfrac{1}{n}\sum_{i=1}^n (X_i - \overline{X}_n)\)</span>이든 둘 다 일치 추정량이라는 것을 쉽게 알 수 있다.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>자세한 내용은 <a href="http://www.utstat.toronto.edu/~brunner/oldclass/413f08/handouts/STA413Ch4.pdf">여기</a> 책의 해당 부분을 참고하라.</p>
</div></div></section>
<section id="regression-t-statistic" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="regression-t-statistic">회귀 분석의 <span class="math inline">\(t-\)</span>통계량</h3>
<p>회귀 분석의 계수의 표본 추정량 <span class="math inline">\(\hat \beta\)</span>는 다음과 같다. <span class="math display">\[
\hat \beta = (X^T X)^{-1}(X y)
\]</span></p>
<p><span class="math display">\[
t_i = \dfrac{\hat \beta_i - \beta}{S \sqrt{(X^T X)_{ii}^{-1}}}
\]</span></p>
<p>with</p>
<p><span class="math display">\[
S(y_i)^2 = \dfrac{1}{n-k} \sum_{i=1}^n (y_i -  x^r_i \hat\beta)
\]</span></p>

<div class="no-row-height column-margin column-container"><div class="">
<p>여기서 <span class="math inline">\(\beta_k\)</span>는 중회귀 분석의 <span class="math inline">\(k\)</span>–번째 계수를 뜻한다.</p>
</div></div><ul>
<li><span class="math inline">\(x^r_i\)</span>: <span class="math inline">\(X\)</span>의 <span class="math inline">\(i\)</span>’th 행(row) 벡터</li>
<li><span class="math inline">\(\underset{(1 \times k)}{x^r_i}\underset{(k \times 1)}{\vphantom{x^r_i}\hat\beta} = \hat y_i\)</span></li>
</ul>
<p>회귀 분석의 <span class="math inline">\(i\)</span>–번째 계수인 <span class="math inline">\(\beta_i\)</span>는 <span class="math inline">\(t_i\)</span>를 통해 검정할 수 있다. <span class="math inline">\(n\)</span>이 충분히 클 경우 <span class="math inline">\(t_i \sim \rm N(0,1)\)</span>이 된다.</p>
</section>
<section id="clt-and-lln-illustrated" class="level3">
<h3 class="anchored" data-anchor-id="clt-and-lln-illustrated">CLT and LLN illustrated</h3>
<p>LLN과 CLT은 동전의 양면처럼 보이기도 한다. 아래 첫번째 그림에서 보듯이 <span class="math inline">\([0,1]\)</span> 사이를 고정해서 보면 표본의 크기가 증가할수록 분산이 줄어들게 되고 추정량이 파라미터 주변으로 모이게 된다. 반면, 두번째 그림에서 보듯이, 표본의 크기에 따라서 <span class="math inline">\(x\)</span> 축의 비율을 조절하면 분포가 점점 정규 분포를 닮아간다.</p>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[[-10, 60, -10]]">
<div class="quarto-layout-row quarto-layout-valign-bottom">
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 12.5%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 75.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://i0.wp.com/lorentzen.ch/wp-content/uploads/2021/01/image-3.png" class="lightbox" data-glightbox="description: .lightbox-desc-3" data-gallery="quarto-lightbox-gallery-3" title="LLN; n이 커짐에 따라서 평균값으로 모이는 현상이 발생한다. 위 그래프와 달리 x 축의 범위를 0, 1 사이로 고정했다."><img src="https://i0.wp.com/lorentzen.ch/wp-content/uploads/2021/01/image-3.png" class="img-fluid figure-img" alt="LLN; n이 커짐에 따라서 평균값으로 모이는 현상이 발생한다. 위 그래프와 달리 x 축의 범위를 0, 1 사이로 고정했다."></a></p>
<figcaption>LLN; <span class="math inline">\(n\)</span>이 커짐에 따라서 평균값으로 모이는 현상이 발생한다. 위 그래프와 달리 <span class="math inline">\(x\)</span> 축의 범위를 0, 1 사이로 고정했다.</figcaption>
</figure>
</div>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 12.5%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
</div>
</div>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[[-10, 60, -10]]">
<div class="quarto-layout-row quarto-layout-valign-bottom">
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 12.5%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 75.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://i0.wp.com/lorentzen.ch/wp-content/uploads/2021/01/image-2.png" class="lightbox" data-glightbox="description: .lightbox-desc-4" data-gallery="quarto-lightbox-gallery-4" title="CLT; 0, 1을 각각 0.8, 0.2의 확률로 갖는 베르누이 분포가 있을 때, 확률 변수의 샘플 크기가 커짐에 따라 표본 평균은 정규 분포를 닮아간다."><img src="https://i0.wp.com/lorentzen.ch/wp-content/uploads/2021/01/image-2.png" class="img-fluid figure-img" alt="CLT; 0, 1을 각각 0.8, 0.2의 확률로 갖는 베르누이 분포가 있을 때, 확률 변수의 샘플 크기가 커짐에 따라 표본 평균은 정규 분포를 닮아간다."></a></p>
<figcaption>CLT; 0, 1을 각각 0.8, 0.2의 확률로 갖는 베르누이 분포가 있을 때, 확률 변수의 샘플 크기가 커짐에 따라 표본 평균은 정규 분포를 닮아간다.</figcaption>
</figure>
</div>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 12.5%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
</div>
</div>


<div class="hidden" aria-hidden="true">
<span class="glightbox-desc lightbox-desc-1">파라미터 값 4를 추정하기 위한 샘플 추정량; 샘플 크기가 증가하면서 4로 접근한다. 예시의 샘플 추정량은 biased된 추정량이다.</span>
<span class="glightbox-desc lightbox-desc-2"><span class="math inline">\(n\)</span>이 커질수록 <span class="math inline">\(\ES{X}_n\)</span>의 분포는 표준 정규 분포에 근접한다. <span class="math inline">\(x_i\)</span>가 추출된 모집단의 분포를 찾는 것이 아니다. 우리에게 중요한 것은 추정량 <span class="math inline">\(\ES{X}_n\)</span>이고 이 녀석의 분포를 묘사하는 것이 CLT이다.</span>
<span class="glightbox-desc lightbox-desc-3">LLN; <span class="math inline">\(n\)</span>이 커짐에 따라서 평균값으로 모이는 현상이 발생한다. 위 그래프와 달리 <span class="math inline">\(x\)</span> 축의 범위를 0, 1 사이로 고정했다.</span>
<span class="glightbox-desc lightbox-desc-4">CLT; 0, 1을 각각 0.8, 0.2의 확률로 갖는 베르누이 분포가 있을 때, 확률 변수의 샘플 크기가 커짐에 따라 표본 평균은 정규 분포를 닮아간다.</span>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"loop":false,"selector":".lightbox","openEffect":"zoom","closeEffect":"zoom","descPosition":"bottom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>