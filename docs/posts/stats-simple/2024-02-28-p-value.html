<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="JS HUHH">
<meta name="dcterms.date" content="2024-02-28">
<meta name="description" content="영가설을 기각하기에 충분한 근거일까?">

<title>lostineconomics.com - p값? 너무 믿지 마세요</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">lostineconomics.com</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../project.html"> 
<span class="menu-text">project</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/anarinsk"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/anarinsk"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">p값? 너무 믿지 마세요</h1>
  <div class="quarto-categories">
    <div class="quarto-category">statistics</div>
    <div class="quarto-category">stats-simple</div>
  </div>
  </div>

<div>
  <div class="description">
    영가설을 기각하기에 충분한 근거일까?
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>JS HUHH </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 28, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-JNRF3S74Z4"></script><section id="tl-dr" class="level2">
<h2 class="anchored" data-anchor-id="tl-dr">TL; DR</h2>
<p>p값에 너무 의지하면 분석의 취지가 망가진다.</p>
</section>
<section id="조건부-확률을-생각하라" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="조건부-확률을-생각하라">조건부 확률을 생각하라!</h2>
<p>p값을 이해할 때 가장 먼저 떠올려야 하는 것은 조건부 확률이다. 조건부 확률에서</p>
<p><span class="math display">\[
P(A|B) \neq P(B|A)
\]</span></p>
<p>이다. <span class="math inline">\(P(\text{E}|H_0)\)</span>을 생각해보자. <span class="math inline">\(H_0\)</span>이 영가설(null hypothesis)이다. E는 증거를 뜻한다. 즉, 관측값이다. 우리가 아는 p값이란 영가설이 맞다고 가정할 때 E라는 증거를 관측할 확률이다. 이는 당연히 <span class="math inline">\(P(H_0|\text{E})\)</span>와는 다르다.</p>
<p>“P의 비극”은 이 둘을 혼동하는 데에서 시작한다.</p>
<section id="an-example" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="an-example">An example</h3>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[[2,-1,2]]">
<div class="quarto-layout-row quarto-layout-valign-bottom">
<div class="quarto-layout-cell" style="flex-basis: 40.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://mastersandmagic.com/cdn/shop/products/product-image-1468072041_2000x.jpg?v=1602738728" class="lightbox" data-glightbox="description: .lightbox-desc-1" data-gallery="quarto-lightbox-gallery-1" title="1~20까지 숫자를 지닌 D&amp;D용 주사위"><img src="https://mastersandmagic.com/cdn/shop/products/product-image-1468072041_2000x.jpg?v=1602738728" class="img-fluid figure-img" alt="1~20까지 숫자를 지닌 D&amp;D용 주사위"></a></p>
<figcaption>1~20까지 숫자를 지닌 D&amp;D용 주사위</figcaption>
</figure>
</div>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 20.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 40.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://ae01.alicdn.com/kf/S35f98360675d434e94b5d9b20e19ed6bE.jpg_640x640Q90.jpg_.webp" class="lightbox" data-glightbox="description: .lightbox-desc-2" data-gallery="quarto-lightbox-gallery-2" title="녹색 모자!"><img src="https://ae01.alicdn.com/kf/S35f98360675d434e94b5d9b20e19ed6bE.jpg_640x640Q90.jpg_.webp" class="img-fluid figure-img" alt="녹색 모자!"></a></p>
<figcaption>녹색 모자!</figcaption>
</figure>
</div>
</div>
</div>
</div>

<div class="no-row-height column-margin column-container"><div class="">
<p>이 사례는 <a href="https://outsidetheasylum.blog/an-actually-intuitive-explanation-of-p-values/">여기</a>에서 가져왔다. 보다 익살스러운 사례로 <a href="https://www.explainxkcd.com/wiki/index.php/882:_Significant">xkcd 882: Significant</a>도 참고하자.</p>
</div></div><p>D&amp;D라는 게임은 다각 20면을 지닌 주사위를 쓴다. 만일 “녹색 모자를 쓰고 주사위를 던질 때 20이 더 잘나온다”는 대립가설(alternative hypothesis)을 세웠다고 하자. 이때 영가설은 “녹색 모자를 쓰는 것은 주사위의 결과에 영향을 미치지 않는다”가 될 것이다. 그리고 녹색 모자를 쓴 채 주사위를 던져서 20을 얻었다. 이때 p값은 어떻게 될까? 0.05이다.</p>
<p><span class="math display">\[
P(\text{E}|H_0) = \dfrac{1}{20} = 0.05
\]</span></p>
<p>(약간 에누리를 더해서) 10% 유의 수준에서 해당 영가설을 넉넉하게 기각할 수 있다! 좀 더 사악한 경우를 상상해볼까? 녹색 모자를 쓰고 주사위를 1000번 쯤 던졌다고 하자. 주사위가 정상이라면 50번 정도는 20이 나왔을 것이다. 해당 장면들만을 편집해서 마치 20번을 던진 것처럼 보이게 만들었다고 하자. 보라, 놀라운 녹색 모자의 효과를!</p>
<p>“녹색 모자를 쓰고 주사위를 던질 때 20이 더 잘 나온다!” 당연히 이상하고 잘못된 진술이다. 수많은 D&amp;D 플레이어들은 이 말이 틀리다는 것을 경험적으로 너무나(!) 잘 알고 있다.</p>
</section>
<section id="베이즈-정리" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="베이즈-정리">베이즈 정리</h3>
<p>사실 우리가 알고 싶은 것이 p값이 아닐지 모른다. 우리는 이 값과는 다른 조건부 확률, 즉 <span class="math inline">\(P(H_0 | \text{E})\)</span>을 알고 싶은 것이다! 영가설을 기각할 때 찾아오는 쾌감을 기억하는가? 이 쾌감이 근거를 지니려면 <span class="math inline">\(P(\cdot)\)</span>의 값이 충분히 작아야 한다!</p>
<p>이 문제를 다루는 데에는 베이즈 정리를 활용할 수 있다.</p>
<p><span class="math display">\[
P(H_0|\text{E}) = \dfrac{P(\text{E}|H_0)P(H_0)}{P(\text{E}|H_0)P(H_0) + P(\text{E}|\neg H_0)P(\neg H_0)}
\]</span></p>
<p>우리가 알고 싶은 답, 즉 E를 관찰할 때 <span class="math inline">\(H_0\)</span>가 맞을 확률에서 p값(<span class="math inline">\(P(\text{E}|H_0\)</span>)은 한 부분으로 들어갈 뿐이다. 앞서 살펴본 D&amp;D의 사례를 응용해보자. 녹색 모자가 주사위에 어떤 물리적인 조작을 가할 수 있는 것이 아닌 이상 <span class="math inline">\(P(H_0)=0.99\)</span>이라고 기대할 수 있다고 하자. 따라서 <span class="math inline">\(P(\neg H_0) = 1 - P(H_0) = 0.01\)</span>이다. 앞서 보았듯이 p값은 0.05이다. 만일 녹색 모자가 어떤 이유에서건 영향을 줄 수 있다면 <span class="math inline">\(P(\text{E}|\neg H_0)=1\)</span>라고 강하게 기대할 수 있다.</p>
<p><span class="math display">\[
P(H_0|\text{E}) = \dfrac{0.05 * 0.999}{0.05 * 0.999 + 1 * 0.001} \approx 0.98
\]</span></p>
<p>20이라는 주사위의 관찰이 영가설의 신뢰성을 약간 훼손시키긴 했지만 그 정도가 심하지는 않다. 이게 대체로 상식적인 결과일 것이다.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>이거 보면 뭔가 떠오르는 게 있는 분들이 있을지도 모르겠다. 유병률이 낮은 질병의 경우 테스트의 정확도(겅정력)이 높더라도 해당 테스트의 양성이 바로 아주 높은 확률의 질병 발생을 의미하지는 않는다. 이게 베이즈 정리의 신비인 것이다.</p>
</div></div><p>p값은 중요하다! 하지만 p값을 강한 의미로 해석하려면, 즉 영가설이 어느 정도나 옳은지의 맥락에서 해석하려면 베이즈 정리의 눈, 즉 사전 지식 혹은 믿음의 맥락에 입각해 한번 더 생각해봐야 할 것이다.</p>
</section>
</section>
<section id="p값은-검정의-성과-지표가-아니다" class="level2">
<h2 class="anchored" data-anchor-id="p값은-검정의-성과-지표가-아니다">p값은 검정의 ’성과 지표’가 아니다!</h2>
<p>p값이 낮으면 낮을수록 좋은 것일까? 이 질문은 미묘하다. p값은 오탐률(false positive)을 통제한다. 여기서 오탐이란 “영가설이 맞는데도 이를 잘못 기각”하는 경우를 의미한다. 오탐률이 낮으면 당연히 좋다. 즉 오탐이 아니라 탐지 못한 것이 맞는 경우, 즉 영가설이 참이면 p값은 아무런 의미가 없다. 다시 베이즈 정리로 돌아가보자.</p>
<p><span class="math display">\[
P(H_0|\text{E}) = \dfrac{P(\text{E}|H_0)P(H_0)}{P(\text{E}|H_0)P(H_0) + P(\text{E}|\neg H_0)P(\neg H_0)}
\]</span></p>
<p>p값은 <span class="math inline">\(P(\text{E}|H_0)\)</span>이다. 통계적인 검정력(statistical power)이란 <span class="math inline">\(P(\text{E}|\neg H_0)\)</span>를 의미한다. p값과 같은 맥락에서 해석해보자. 해당 증거를 보고 영가설을 올바르게 기각할 확률이 된다. 즉 이는 true positive의 확률을 의미한다. 그리고 prevalence, 즉 유병률은 <span class="math inline">\(P(\neg H_0)\)</span>이다. 이는 검정하려는 가설에 관한 일종의 사전 정보 혹은 믿음을 나타낸다.</p>
<section id="종-오류와-2종-오류" class="level3">
<h3 class="anchored" data-anchor-id="종-오류와-2종-오류">1종 오류와 2종 오류</h3>
<p>위의 내용은 1종 오류, 2종 오류 그리고 이진 분류와 관련되어 있다.</p>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[10,-0.1,10]">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 49.8%;justify-content: center;">
<div id="tbl-error" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-error-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Error types
</figcaption>
<div aria-describedby="tbl-error-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 28%">
<col style="width: 35%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: center;"><span class="math inline">\(H_0\)</span> is true</th>
<th style="text-align: center;"><span class="math inline">\(H_0\)</span> is false</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">reject <span class="math inline">\(H_0\)</span></td>
<td style="text-align: center;">false positive(<span class="math inline">\(\alpha\)</span>)</td>
<td style="text-align: center;">true positive(<span class="math inline">\(1-\beta\)</span>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">aceept <span class="math inline">\(H_0\)</span></td>
<td style="text-align: center;">true negative(<span class="math inline">\(1-\alpha\)</span>)</td>
<td style="text-align: center;">false negative(<span class="math inline">\(\beta\)</span>)</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 0.5%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 49.8%;justify-content: center;">
<div id="tbl-binary" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-binary-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2: Binary classification
</figcaption>
<div aria-describedby="tbl-binary-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 28%">
<col style="width: 35%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: center;">Negative</th>
<th style="text-align: center;">Positive</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">predicted Positve</td>
<td style="text-align: center;">false positive(<span class="math inline">\(\alpha\)</span>)</td>
<td style="text-align: center;">true positive(<span class="math inline">\(1-\beta\)</span>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">predicted Negative</td>
<td style="text-align: center;">true negative(<span class="math inline">\(1-\alpha\)</span>)</td>
<td style="text-align: center;">false negative(<span class="math inline">\(\beta\)</span>)</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</div>
</div>
</div>
<p>몇 가지 용어를 정리해보자.</p>
<ul>
<li>false positive의 허용 확률 <span class="math inline">\(\alpha\)</span>가 1종 오류(type I error)이다. 유의수준(significance level)이라고도 한다.</li>
<li>false negative의 허용 확률 <span class="math inline">\(\beta\)</span>가 2종 오류(type II error)이다. <span class="math inline">\((1-\beta)\)</span>를 통계적 검정력(statistical power)이라고 한다.</li>
<li>세계의 상태가 결정되어 있다고 하자. 결정된 세계의 상태는 위의 표에서 두 열 중 하나다. 따라서 해당 열에 대한 허용 확률의 합은 1이 된다. 즉, 오탐(false positive) + 정미탐(true negative)의 확률, 그리고 정탐(true positive) + 미탐(false negative)의 확률은 각각 1이어야 한다.</li>
<li>행의 합은 그렇지 않다. 왜그럴까?</li>
<li>Negative의 크기를 <span class="math inline">\(N\)</span>, Positive의 크기를 <span class="math inline">\(P\)</span>라고 하자. 이때 유병률은 <span class="math inline">\(\frac{P}{P+N}\)</span>이다. 이 값은 <span class="math inline">\(P(\neg H_0)\)</span>와 같다.</li>
</ul>
</section>
<section id="alpha와-beta의-tradeoff" class="level3">
<h3 class="anchored" data-anchor-id="alpha와-beta의-tradeoff"><span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\beta\)</span>의 tradeoff</h3>
<p>우리가 알고 싶은 값을 <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>를 넣어서 다시 써보자.</p>
<p><span class="math display">\[
P(H_0|\text{E}) = \dfrac{\alpha P(H_0)}{\alpha P(H_0) + (1-\beta)P(\neg H_0)}
\]</span></p>
<p>증거 E를 관찰했을 때 영가설을 기각할 확률을 높이려면 위의 확률을 낮춰야 한다. <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\beta\)</span>가 모두 낮을수록 해당 확률은 낮아진다. 그렇다면 이 둘을 모두 낮추면 좋지 않을까? 불행하게도 이는 불가능하다.</p>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[[-1,4,-1]]">
<div class="quarto-layout-row quarto-layout-valign-bottom">
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 16.7%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 66.7%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://i.stack.imgur.com/x1GQ1.png" class="lightbox" data-glightbox="description: .lightbox-desc-3" data-gallery="quarto-lightbox-gallery-3" title="기준 점을 잡게 되면 1종 오류와 2종 오류의 트레이드오프가 발생한다."><img src="https://i.stack.imgur.com/x1GQ1.png" class="img-fluid figure-img" alt="기준 점을 잡게 되면 1종 오류와 2종 오류의 트레이드오프가 발생한다."></a></p>
<figcaption>기준 점을 잡게 되면 1종 오류와 2종 오류의 트레이드오프가 발생한다.</figcaption>
</figure>
</div>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 16.7%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
</div>
</div>
<p>위 그림을 보자. 영가설을 잡았고 이론적인 대립가설은 그림과 같다. 만일 영가설과 대립가설이 충분히 떨어져 있어서 겹치는 부분이 없다면 행복할 것이다. 두 에러 모두 0으로 만드는 것이 가능하다. 하지만 이런 경우는 대체로 흥미롭지 않은 경우다. 통계적인 작업이 필요하지 않은 자명한 경우가 거의 대분일 것이다. 만일 사람들이 흥미로워하는데도 이런 통계학적인 상태에 있는 주제가 있다면 어서 논문을 쓰시기 바란다!</p>
<p>위 그림에서 보듯이 “any mean”을 기준으로 1종 오류와 2종 오류를 구별할 수 있는데, 두 분포가 겹치는 부분이 있는 이상 둘의 트레이드오프는 어쩔 수 없이 발생한다.</p>
</section>
<section id="출판-편향과-p값" class="level3">
<h3 class="anchored" data-anchor-id="출판-편향과-p값">출판 편향과 p값</h3>
<p>유병률이 낮은 경우 대부분의 관찰은 true negative에 속하게 된다. 이 경우는 흥미를 끌지 못하게 된다. 세간에서 “당연한 걸 뭘 보냐”라는 경우다.” 유병률이 낮을 때 유병(positive)을 관찰한다면 이건 주목을 끌게 된다. 이렇게 주목을 끌게 되는 그리고 주목을 끌고자 하는 저자의 의도가 출판 편향(publication bias)을 낳는다.</p>
<p>출판된 positive 중에서 true positive의 비율이 얼마나 될까? 이를 결정하는 것이 <span class="math inline">\(\alpha\)</span>, 즉 유의 수준과 통계적 검정력이 된다. 대략 <span class="math inline">\(\alpha=0.1\)</span> 그리고 통계적 검정력(<span class="math inline">\(1-\beta\)</span>)를 0.6 정도를 가정하자. 이 정도도 관대한 것이다. 그리고 출판 편향이 문제가 되는 상황을 보기 위해서 유병률은 0.1 정도라고 가정하자. <span class="math inline">\(N=900, P=100\)</span>이라고 가정하고 각각의 셀의 숫자를 채워보자.</p>
<table class="table">
<thead>
<tr class="header">
<th></th>
<th><span class="math inline">\(H_0\)</span> is true (<span class="math inline">\(N=900\)</span>)</th>
<th><span class="math inline">\(H_0\)</span> is false (<span class="math inline">\(P=100\)</span>)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>reject <span class="math inline">\(H_0\)</span></td>
<td>false positive(0.1), 90</td>
<td>true positive(0.6), 60</td>
</tr>
<tr class="even">
<td>accept <span class="math inline">\(H_0\)</span></td>
<td>true negative(0.9), 810</td>
<td>false negative(0.4), 40</td>
</tr>
</tbody>
</table>
<p>Positive라고 보고한 결과, 즉 <span class="math inline">\(H_0\)</span>을 reject한 연구 중에서 오직 40%(<span class="math inline">\(\frac{60}{90+60}\)</span>)만 타당한 결과다. 나머지 60%는 false positive에 속한다!</p>
</section>
<section id="p값은-낮을수록-좋은가" class="level3">
<h3 class="anchored" data-anchor-id="p값은-낮을수록-좋은가">p값은 낮을수록 좋은가?</h3>
<p>만일 <span class="math inline">\(P(\text{E}|\neg H_0)\)</span> 혹은 <span class="math inline">\((1-\beta)\)</span>의 값이 고정되어 있다면, p값, 즉 <span class="math inline">\(\alpha\)</span> 혹은 <span class="math inline">\(P(\text{E}|H_0)\)</span>값이 낮을수록 <span class="math inline">\(P(H_0|\text{E})\)</span> 역시 작아질 것이다. 하지만 위에서 보듯이 영가설과 대립가설의 분포가 겹쳐 있는 상황에서 p값이 작다는 것 즉, 1종 오류를 아주 작게 줄인다는 것은 대개의 경우 2종 오류를 늘이게 된다. 즉, <span class="math inline">\((1-\beta)\)</span>는 작아지고 우리가 마음 속으로 바라고 있는 값, E라는 증거가 발견되었는데도 영가설 <span class="math inline">\(H_0\)</span>가 맞을 확률은 높아진다. 이 때 <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\beta\)</span> 중에서 어떤 것이 <span class="math inline">\(P(H_0|\text{E})\)</span> 변화에 더 큰 영향을 줄것인지는 따져봐야 알 수 있다.</p>
</section>
</section>
<section id="그래서-뭐-어쩌라고" class="level2">
<h2 class="anchored" data-anchor-id="그래서-뭐-어쩌라고">그래서, 뭐 어쩌라고?</h2>
<p>통계학은 그 단어와 학문이 품은 ‘모호함’ 만큼 조심스럽게 해석하고 접근해야 한다. 세상의 모든 일이 그렇지만 언제나 ’맥락’이 중요하다. 오늘의 교훈이다. p값 역시 그러한 맥락을 잊지 말자.</p>


<div class="hidden" aria-hidden="true">
<span class="glightbox-desc lightbox-desc-1">1~20까지 숫자를 지닌 D&amp;D용 주사위</span>
<span class="glightbox-desc lightbox-desc-2">녹색 모자!</span>
<span class="glightbox-desc lightbox-desc-3">기준 점을 잡게 되면 1종 오류와 2종 오류의 트레이드오프가 발생한다.</span>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/www\.lostineconomics\.com\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"loop":false,"closeEffect":"zoom","selector":".lightbox","descPosition":"bottom","openEffect":"zoom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>